
# line 2 "src/7.1/cfe/c.y"
#include "common.h"
char* ident = "$Header: /hosts/bonnie/proj/irix6.4-ssg/isms/cmplrs/targucode/cfe/RCS/c.y,v 1.17 1995/02/27 21:57:39 rdahl Exp $";

#define YYMAXDEPTH 800

typedef struct UnkBeta {
    LinkedListEntry link;
    Symbol* unk_04;
} UnkBeta;

static LinkedList* B_10020F00;
static int B_10020F04;
static LinkedList* B_10020F08;
static TreeNodeList B_10020F10;

int yyparse(void);

#define LINK_PUSH_BACK(list, item) \
{ \
	TreeNode* ptr; \
	TreeNode* prev; \
	for (ptr = list, prev = list; ptr != NULL; ptr = TREE_LINK(ptr)) { \
		prev = ptr; \
	} \
	TREE_LINK(prev) = item; \
}

#define TYPE_PUSH_BACK(list, item) \
{ \
	TreeNode* ptr; \
	TreeNode* prev; \
	for (ptr = list, prev = list; ptr != NULL; ptr = TREE_TYPE(ptr)) { \
		prev = ptr; \
	} \
	TREE_TYPE(prev) = item; \
}

#define QUALIFIERS_PUSH_BACK(id_decl, qual) \
{ \
	TreeNode* ptr; \
	TreeNode* prev; \
	for (prev = ptr = ID_DECL(id_decl).qualifiers; ptr != NULL; ptr = TREE_TYPE(ptr)) { \
		prev = ptr; \
	} \
	if (prev == NULL) { \
		ID_DECL(id_decl).qualifiers = qual; \
	} else { \
		TREE_TYPE(prev) = qual; \
	} \
}

// TODO remove error() from yaccpar and probably replace ti with macro

void parse_init(void) {
    if (B_10020F00 == NULL) {
        B_10020F00 = link_start(general_handle, sizeof(UnkChi));
    } else {
        free_link_list(B_10020F00);
    }

    if (B_10020F08 == NULL) {
        B_10020F08 = link_start(general_handle, sizeof(UnkBeta));
    }

    cur_lvl = (UnkChi*)get_link_elem(B_10020F00);
    cur_lvl->unk_04 = 1;
    cur_lvl->unk_08 = 1;
    cur_lvl->unk_0C = 0;
    cur_lvl->in_struct_def = FALSE;
    cur_lvl->link.next = B_10020F00->used_list;
    B_10020F00->used_list = &cur_lvl->link;

    B_10020F04 = 0;
    tree_handle = general_handle;    
}

TreeNode* parse(void) {
    temp_handle = mem_start();
    B_10020F10.first = NULL;
    B_10020F10.last = NULL;
    parse_init();
    if (yyparse() != 0) {
        return NULL;
    } else {
        return B_10020F10.first;
    }
}

void delete_local_decls(int arg0) {
    UnkBeta* s2 = (UnkBeta*)B_10020F08->used_list;
    ParseSymbol* s1;

    while (s2 != NULL) {
        if (s2 == NULL) {
            return;
        }
        s1 = s2->unk_04->psymb;
        
        if (s1 == NULL) {
            link_pop(B_10020F08);
            return;
        }
        if (s1->level < arg0) {
            return;
        }

        while (s1 != NULL && s1->level >= arg0) {
            ParseSymbol* s0 = (ParseSymbol*)s1->link.next;
            if (debug_arr[80] > 0) {
                fprintf(dbgout, "deleting %.*s (0x%x:%d:%s) unhides (0x%x:%d:%s)\n",
                        s2->unk_04->namelen, s2->unk_04->name,
                        s1, s1->unk_08, GET_SYM_CAT(s1->id),
                        s0, s0 != NULL ? s0->unk_08 : -1, s0 != NULL ? GET_SYM_CAT(s0->id) : "<nil>");
            }

            s1->link.next = psymb_handle->free_list;
            psymb_handle->free_list = &s1->link;
            s1 = s0;
            s2->unk_04->psymb = s0;
        }
        s2 = link_pop(B_10020F08);
    }
}

TreeNode* make_topdecl(TreeNode* type, int attr, int typespec, TreeNode* ids, int location) {
    TreeNode* v1;
    
    v1 = make(Declare_decl, location, NULL, ids);
	TREE_ATTRIBUTE(v1) = attr;
    if (type != NULL) {
		TREE_TYPE(v1) = type;
        if (typespec != 0) {
            error(0x2010F, LEVEL_WARNING, location);
        }
        return v1;
    } else {
        TREE_TYPE(v1) = normalize_type(typespec, location);
        if (was_plain_char(typespec)) {
            TREE_ATTRIBUTE(v1) |= PLAIN_ATTRIBUTE;
        }
        return v1;
    }
}

static void* func_00409D18(int code, int location, TreeNode* arg2) {
	// TODO type of arg2
    TreeNode* zeta;
    TreeNode* v0;    
    
    if (!options[OPTION_MSFT]) {
        error(0x3015A, LEVEL_WARNING, location);
    }
    
    if (arg2 == NULL || BINARY_EXPR(arg2).operand[0] == NULL) {
        return NULL;
    }

    zeta = BINARY_EXPR(BINARY_EXPR(arg2).operand[0]).operand[0];
    v0 = make(Pointer_type, location, zeta, arg2);
    POINTER_TYPE(v0).size = bit_size[9];
    POINTER_TYPE(v0).align = bit_size[9];


    if (zeta == NULL) {
		BINARY_EXPR(BINARY_EXPR(arg2).operand[0]).operand[0] = v0;
    } else {
        TreeNode* ptr = zeta;
        TreeNode* a0 = ptr;
        
        while (ptr != NULL) {
            a0 = ptr;
            ptr = TREE_TYPE(ptr);
        }
        TREE_TYPE(a0) = v0;
    }
    return make(code, location, make(Indirect_expr, location, arg2));
}


# line 182 "src/7.1/cfe/c.y"
typedef union
#ifdef __cplusplus
	YYSTYPE
#endif
 {
	int location;
	TreeNode* node; 
	struct TokenIdentifier identifier;
	struct DeclSpec declspec;
	struct Declarator declarator;
	struct TreeNodeList list;
} YYSTYPE;
# define IDENTIFIER 257
# define SIZEOF 258
# define ALIGNOF 259
# define CLASSOF 260
# define UNALIGN 261
# define STRING 262
# define WSTRING 263
# define CONSTANT 264
# define PTR_OP 265
# define INC_OP 266
# define DEC_OP 267
# define LEFT_OP 268
# define RIGHT_OP 269
# define LE_OP 270
# define AND_OP 271
# define OR_OP 272
# define GE_OP 273
# define NE_OP 274
# define EQ_OP 275
# define MUL_ASSIGN 276
# define DIV_ASSIGN 277
# define REM_ASSIGN 278
# define ADD_ASSIGN 279
# define SUB_ASSIGN 280
# define LEFT_ASSIGN 281
# define RIGHT_ASSIGN 282
# define AND_ASSIGN 283
# define XOR_ASSIGN 284
# define OR_ASSIGN 285
# define TYPEDEF 286
# define EXTERN 287
# define STATIC 288
# define AUTO 289
# define REGISTER 290
# define CHAR 291
# define SHORT 292
# define INT 293
# define LONG 294
# define LONGLONG 295
# define SIGNED 296
# define UNSIGNED 297
# define FLOAT 298
# define DOUBLE 299
# define CONST 300
# define VOLATILE 301
# define VOID 302
# define STRUCT 303
# define UNION 304
# define ENUM 305
# define ELLIPSIS 306
# define TYPE_IDENT 307
# define CASE 308
# define DEFAULT 309
# define IF 310
# define ELSE 311
# define SWITCH 312
# define WHILE 313
# define DO 314
# define FOR 315
# define GOTO 316
# define LEAVE 317
# define CONTINUE 318
# define BREAK 319
# define RETURN 320
# define TRY 321
# define EXCEPT 322
# define FINALLY 323
# define __PRAGMA 324
# define CLASS 325
# define VIRTUAL 326
# define PROTECTED 327
# define PUBLIC 328
# define PRIVATE 329
# define COLONCOLON 330
# define COLCOLSTAR 331
# define OPERATOR 332
# define THIS 333
# define MEMDOT_OP 334
# define MEMPTR_OP 335
# define NEW 336
# define DELETE 337
# define INLINE 338
# define FRIEND 339

#include <malloc.h>
#include <memory.h>
#include <values.h>

#ifdef __cplusplus

#ifndef yyerror
	void yyerror(const char *);
#endif
#ifndef yylex
	int yylex(void);
#endif
	int yyparse(void);

#endif
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern int yyerrflag;
YYSTYPE yylval;
YYSTYPE yyval;
typedef int yytabelem;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
#if YYMAXDEPTH > 0
int yy_yys[YYMAXDEPTH], *yys = yy_yys;
YYSTYPE yy_yyv[YYMAXDEPTH], *yyv = yy_yyv;
#else	/* user does initial allocation */
int *yys;
YYSTYPE *yyv;
#endif
static int yymaxdepth = YYMAXDEPTH;
# define YYERRCODE 256

# line 1782 "src/7.1/cfe/c.y"

yytabelem yyexca[] ={
-1, 0,
	0, 280,
	-2, 0,
-1, 1,
	0, -1,
	-2, 0,
-1, 2,
	0, 279,
	-2, 0,
-1, 66,
	44, 110,
	59, 110,
	-2, 275,
-1, 80,
	123, 157,
	-2, 159,
-1, 284,
	44, 186,
	-2, 188,
-1, 409,
	44, 187,
	-2, 190,
	};
# define YYNPROD 281
# define YYLAST 1928
yytabelem yyact[]={

    39,   107,   150,   127,    82,   124,   138,   280,   401,   277,
   343,   344,   338,    54,   360,   195,     9,   439,   212,   223,
   222,   279,   226,   204,   227,    81,   273,    66,   192,    78,
   275,   228,   229,    21,    13,    59,    10,    73,    10,    70,
   167,    85,   111,   270,   158,    20,   162,    42,    12,   410,
   281,   111,    86,   271,   111,    83,    75,   134,   285,   120,
   252,    80,    72,    99,   351,    18,   163,    92,    53,   436,
   411,   114,   166,   404,   398,   357,   153,    27,    28,    29,
    30,    31,    32,    33,    34,    35,    40,    41,    36,    47,
    48,    49,   118,    46,    57,   110,   193,    17,   299,    70,
    21,   106,    14,   219,   272,   122,   168,    58,    65,   170,
   117,   159,    20,    62,    21,   282,   174,   172,   271,    20,
    21,    21,   160,   238,   134,   220,    15,   245,   236,   431,
   403,   396,   262,   299,   362,    21,    52,    63,   434,    71,
    11,   299,   332,   238,    71,   453,   245,   211,   250,   272,
   119,    60,   245,   258,   256,   245,   245,    65,   245,    54,
   433,   447,    62,    77,    68,   408,   358,   427,   341,   272,
   388,   342,   368,   153,   287,   115,   372,   159,   284,   259,
   243,    83,   290,   289,   272,   267,    63,   206,   160,   278,
   349,   116,   272,   207,   257,    69,   245,   254,    68,   292,
   151,   253,    68,   269,   242,   361,   193,   244,   241,   307,
   193,   246,   304,   154,   367,   365,   196,    67,   119,   266,
   432,   193,   261,   193,   260,   193,   234,   420,   419,   240,
   298,   232,   224,   268,   418,   225,   233,   191,   205,   416,
   415,   238,   238,   286,   160,   238,   236,   330,   334,   230,
   333,   231,    42,   397,   335,   336,   337,   160,   340,   291,
   297,   466,    19,   395,   245,   369,    65,   345,   303,   364,
    19,    62,   160,   160,   160,   160,   160,   160,   160,   160,
   160,   160,   160,   160,   160,   326,   327,   328,    73,   105,
   278,    40,    41,   315,    95,    63,    89,   350,   101,   102,
   196,   103,   168,   366,   363,   356,   269,   347,   193,   168,
   375,   376,   180,   348,   159,   137,   314,   353,    72,    42,
   355,   313,   295,   324,   325,   160,   196,   263,   458,    19,
   196,   245,   238,   238,   298,    19,    19,   380,   381,   322,
   323,   196,   348,   196,   456,   196,   387,   245,   390,    27,
    28,    29,    30,    31,    32,    33,    34,    35,    40,    41,
    36,    47,    48,    49,   169,    46,    55,   409,   399,   405,
    83,   389,   412,   385,   278,   350,   402,   417,   407,    58,
   251,   239,   104,   238,   238,   238,   168,   194,   421,   422,
   423,   159,   424,   426,   392,   429,   430,   394,   316,   317,
   448,   196,   160,   245,   159,   295,   442,   406,   440,   245,
   413,   245,   208,   209,   210,   160,   318,   319,   320,   321,
   249,   160,   414,   123,   384,   383,   238,   245,   245,   382,
   373,   441,   245,   374,   444,   446,   293,   221,   264,   245,
   238,   265,   155,   238,   238,   452,   238,   177,   454,   455,
   176,   457,   461,   248,   460,   247,    51,   238,   462,   238,
   238,   331,   463,    52,   464,   465,   402,   238,   437,   438,
     3,   178,   467,    50,   175,    79,   159,   159,   435,   450,
   451,   449,   359,   173,   274,   196,   156,   160,   160,   371,
   370,   294,   379,   105,   378,   377,   309,   308,    95,    56,
    89,     1,   101,   102,     4,   103,   288,   164,   283,    74,
    38,    45,   125,   133,    96,    97,    98,    42,   112,   137,
   113,   400,    91,    90,   276,    58,    44,   181,   182,   183,
   184,   185,   186,   187,   188,   189,   190,    37,     5,   179,
    87,    94,    22,    23,    24,    25,    26,    27,    28,    29,
    30,    31,    32,    33,    34,    35,    40,    41,    36,    47,
    48,    49,   305,    46,   135,   136,   139,    93,   140,   141,
   142,   143,   144,   148,   145,   146,   147,   149,   100,    20,
     2,    21,   132,    58,   130,   121,   104,   300,   131,   128,
   129,   302,   126,   108,    43,   109,     0,    16,     6,     0,
     0,     0,   310,     0,   311,     0,   312,     0,    64,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,    76,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   271,     0,    21,   105,     0,     0,     0,     0,
    95,     0,    89,   459,   101,   102,    88,   103,     0,     0,
     0,     0,     0,     0,    20,     0,    21,    64,     0,     0,
     0,     0,     0,    42,     0,     0,     0,     0,     0,     0,
     0,     0,   171,   152,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   272,     0,     0,     0,   197,    22,    23,
    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
    34,    35,    40,    41,    36,    47,    48,    49,     0,    46,
     0,    20,     0,    21,     0,     0,   125,   133,    96,    97,
    98,    42,   112,     0,   113,     0,    91,    90,   104,     0,
    61,     0,     0,     0,   161,     0,     0,   198,   202,     0,
    43,     0,     0,   213,   215,   217,    22,    23,    24,    25,
    26,    27,    28,    29,    30,    31,    32,    33,    34,    35,
    40,    41,    36,    47,    48,    49,    64,    46,   135,   136,
   139,   197,   140,   141,   142,   143,   144,   148,   145,   146,
   147,   149,     0,     0,     0,     0,     0,   393,     0,     0,
     0,     0,     0,   296,     0,     7,    19,   197,    43,     0,
    42,   197,     0,     0,     0,     0,     0,     0,     0,   354,
     0,     0,   197,     0,   197,     0,   197,     0,     0,     0,
     0,     0,     0,     0,     0,    22,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    32,    33,    34,    35,    40,
    41,    36,    47,    48,    49,     0,    46,   202,   198,    19,
     0,     0,     0,    42,     0,     0,     0,     0,     0,   111,
    96,    97,    98,     8,   112,     0,   113,     0,    91,    90,
     0,    19,   197,     0,     0,    42,   296,    43,    22,    23,
    24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
    34,    35,    40,    41,    36,    47,    48,    49,     0,    46,
    22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
    32,    33,    34,    35,    40,    41,    36,    47,    48,    49,
     0,    46,     0,     0,     0,     0,     0,     0,    19,   105,
    43,     0,    42,     0,    95,     0,    89,   445,   101,   102,
     0,   103,     0,     0,     0,     0,     0,     0,     0,     0,
   111,     0,    43,     0,    42,     0,   197,    22,    23,    24,
    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
    35,    40,    41,    36,    47,    48,    49,     0,    46,    22,
    23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
    33,    34,    35,    40,    41,    36,    47,    48,    49,   165,
    46,    58,     0,     0,     0,     0,     0,    42,     0,    43,
     0,   105,     0,     0,     0,     0,    95,     0,    89,     0,
   101,   102,   104,   103,     0,     0,     0,     0,     0,    42,
     0,    43,    22,    23,    24,    25,    26,    27,    28,    29,
    30,    31,    32,    33,    34,    35,    40,    41,    36,    47,
    48,    49,   165,    46,    22,    23,    24,    25,    26,    27,
    28,    29,    30,    31,    32,    33,    34,    35,    40,    41,
    36,    47,    48,    49,   165,    46,     0,     0,     0,     0,
     0,     0,    42,     0,    43,     0,     0,     0,     0,     0,
     0,     0,     0,   105,     0,     0,     0,     0,    95,     0,
    89,   443,   101,   102,   104,   103,    43,    22,    23,    24,
    25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
    35,    40,    41,    36,    47,    48,    49,   346,    46,     0,
     0,   105,     0,     0,     0,     0,    95,     0,    89,    42,
   101,   102,     0,   103,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   111,    96,    97,    98,   137,   112,    43,
   113,     0,    91,    90,    22,    23,    24,    25,    26,    27,
    28,    29,    30,    31,    32,    33,    34,    35,    40,    41,
    36,    47,    48,    49,     0,    46,   104,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   105,
     0,     0,     0,     0,    95,     0,    89,     0,   101,   102,
     0,   103,     0,     0,     0,     0,    43,     0,     0,     0,
     0,    58,   105,   329,   104,   137,     0,    95,     0,    89,
     0,   101,   102,     0,   103,   111,    96,    97,    98,    42,
   112,     0,   113,     0,    91,    90,     0,     0,   137,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,    27,
    28,    29,    30,    31,    32,    33,    34,    35,    40,    41,
    36,    47,    48,    49,     0,    46,     0,     0,   105,    58,
     0,   235,   104,    95,     0,    89,     0,   101,   102,   105,
   103,     0,     0,     0,    95,     0,    89,   425,   101,   102,
     0,   103,    58,     0,   428,   104,     0,   111,    96,    97,
    98,     0,   112,     0,   113,     0,    91,    90,   105,     0,
     0,     0,     0,    95,     0,    89,     0,   101,   102,     0,
   103,   105,     0,     0,     0,     0,    95,     0,    89,     0,
   101,   102,     0,   103,   237,   133,    96,    97,    98,     0,
   112,   105,   113,     0,    91,    90,    95,     0,    89,     0,
   101,   102,     0,   103,     0,     0,     0,     0,     0,     0,
     0,   104,     0,     0,   105,     0,     0,   386,   391,    95,
     0,    89,   104,   101,   102,     0,   103,     0,     0,     0,
     0,     0,     0,     0,     0,    46,   135,   136,   139,     0,
   140,   141,   142,   143,   144,   148,   145,   146,   147,   149,
     0,   104,   237,   133,    96,    97,    98,     0,   112,     0,
   113,    84,    91,    90,   104,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   352,     0,   133,    96,    97,    98,
     0,   112,   105,   113,   104,    91,    90,    95,     0,    89,
   306,   101,   102,     0,   103,     0,     0,     0,     0,     0,
     0,     0,     0,    46,   135,   136,   139,   104,   140,   141,
   142,   143,   144,   148,   145,   146,   147,   149,     0,     0,
     0,     0,     0,     0,     0,     0,    46,   135,   136,   139,
     0,   140,   141,   142,   143,   144,   148,   145,   146,   147,
   149,     0,   111,    96,    97,    98,     0,   112,     0,   113,
     0,    91,    90,   111,    96,    97,    98,     0,   112,     0,
   113,     0,    91,    90,   105,     0,     0,     0,     0,    95,
     0,    89,     0,   101,   102,   104,   103,     0,     0,     0,
     0,     0,   111,    96,    97,    98,     0,   112,     0,   113,
   339,    91,    90,     0,     0,   111,    96,    97,    98,     0,
   112,   105,   113,     0,    91,    90,    95,     0,    89,     0,
   101,   102,     0,   103,     0,   111,    96,    97,    98,     0,
   112,   105,   113,     0,    91,    90,    95,   255,    89,     0,
   101,   102,     0,   103,     0,     0,     0,     0,   111,    96,
    97,    98,     0,   112,   105,   113,     0,    91,    90,    95,
     0,    89,     0,   101,   102,   105,   103,   104,     0,     0,
    95,     0,   301,     0,   101,   102,   105,   103,     0,     0,
     0,    95,     0,   218,     0,   101,   102,   105,   103,     0,
     0,   157,    95,     0,   216,     0,   101,   102,   105,   103,
     0,     0,     0,    95,   104,   214,     0,   101,   102,     0,
   103,     0,     0,     0,     0,     0,   111,    96,    97,    98,
     0,   112,   105,   113,   104,    91,    90,    95,     0,   203,
     0,   101,   102,   105,   103,     0,     0,     0,    95,     0,
   199,     0,   101,   102,     0,   103,     0,   104,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   104,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   104,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   104,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   104,     0,     0,     0,     0,     0,     0,   111,    96,
    97,    98,     0,   112,     0,   113,     0,    91,    90,     0,
     0,     0,     0,     0,     0,   104,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   104,     0,     0,     0,
     0,     0,     0,     0,     0,   111,    96,    97,    98,     0,
   112,     0,   113,     0,    91,    90,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   111,    96,    97,    98,     0,
   112,     0,   113,     0,    91,    90,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   111,    96,
    97,    98,     0,   112,     0,   113,     0,    91,    90,   111,
    96,    97,    98,     0,   112,     0,   113,     0,   200,   201,
   111,    96,    97,    98,     0,   112,     0,   113,     0,   200,
   201,   111,    96,    97,    98,     0,   112,     0,   113,     0,
   200,   201,   111,    96,    97,    98,     0,   112,     0,   113,
     0,   200,   201,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   111,    96,    97,    98,
     0,   112,     0,   113,     0,   200,   201,   111,    96,    97,
    98,     0,   112,     0,   113,     0,   200,   201 };
yytabelem yypact[]={

   539,-10000000,   539,-10000000,-10000000,-10000000,-10000000,-10000000,   416,   402,
   671,   158,   104,     5,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
    79,    -9,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,   -94,  -196,-10000000,-10000000,-10000000,-10000000,
-10000000,  -239,  1308,-10000000,-10000000,   878,   460,-10000000,-10000000,   614,
   154,-10000000,-10000000,-10000000,-10000000,-10000000,    75,-10000000,-10000000,  1558,
   693,-10000000,   104,   323,    -9,-10000000,-10000000,    -6,-10000000,    -7,
-10000000,   406,-10000000,-10000000,-10000000,-10000000,   251,   -35,-10000000,   978,
  1660,  1649,  -248,   147,  1581,  -288,  1625,  1614,  1603,   -21,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,    31,-10000000,-10000000,-10000000,
   399,-10000000,-10000000,-10000000,  -255,   -38,  -237,   206,   189,-10000000,
-10000000,-10000000,  1166,   256,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,   150,   146,  1581,   149,-10000000,   152,   415,
   413,   380,  1189,   340,  -197,   142,   138,  1538,   135,   -16,
-10000000,   120,-10000000,    75,-10000000,   878,    79,-10000000,    39,-10000000,
-10000000,-10000000,   286,   397,   175,-10000000,-10000000,-10000000,   592,-10000000,
-10000000,-10000000,-10000000,  -214,  -207,    -8,  -206,   115,  1308,  1581,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,
-10000000,  1581,  1581,   395,-10000000,    58,-10000000,-10000000,-10000000,   978,
  1592,  1592,-10000000,   978,  1581,  1581,  1419,-10000000,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,   978,-10000000,   978,-10000000,   978,  1581,
  1581,  1581,  1581,  1581,  1581,  1581,  1581,  1581,  1581,  1581,
  1581,  1581,  1581,  1581,  1581,-10000000,-10000000,-10000000,   146,-10000000,
  1098,  1189,-10000000,    84,  1189,  1581,-10000000,  1581,  1581,  1581,
  -301,  1501,   109,-10000000,-10000000,-10000000,   112,-10000000,  -312,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,  -203,   821,-10000000,-10000000,    13,
    99,    78,  1351,   768,  -214,   -50,   107,-10000000,  -214,   161,
-10000000,    73,  -207,   228,-10000000,-10000000,   171,-10000000,   170,-10000000,
-10000000,  -248,   114,-10000000,   224,-10000000,-10000000,-10000000,   101,    93,
-10000000,  1581,-10000000,   -21,    83,   389,-10000000,-10000000,  -203,  -203,
-10000000,-10000000,-10000000,    31,   399,  -255,   -38,   -38,  -237,  -237,
  -237,  -237,   206,   206,   189,   189,-10000000,-10000000,-10000000,-10000000,
-10000000,  1189,  1189,-10000000,-10000000,   388,   384,   383,   333,  1328,
   111,-10000000,-10000000,   331,   -16,-10000000,-10000000,-10000000,    99,  1295,
   746,   222,-10000000,    38,-10000000,   212,   -51,-10000000,  -214,    72,
   -52,  -207,  1581,   161,   106,  -215,   -55,  1308,  1581,  1581,
   199,   198,-10000000,-10000000,  1581,-10000000,-10000000,   193,   187,   186,
-10000000,-10000000,  1189,  1189,  1189,  1581,  1266,   108,  1255,  1581,
-10000000,-10000000,    36,-10000000,   179,-10000000,-10000000,-10000000,-10000000,-10000000,
   116,-10000000,    80,-10000000,-10000000,-10000000,-10000000,   -56,-10000000,-10000000,
-10000000,-10000000,-10000000,-10000000,-10000000,  1581,  1581,-10000000,-10000000,-10000000,
-10000000,  -294,-10000000,-10000000,   367,  1189,   365,  1060,   896,   102,
   359,-10000000,-10000000,-10000000,  1581,  1581,-10000000,-10000000,-10000000,  1189,
    86,-10000000,  1189,  1189,   303,  1189,   287,   602,   -16,    72,
-10000000,-10000000,-10000000,-10000000,-10000000,-10000000,  1189,-10000000,  1189,  1189,
   220,-10000000,-10000000,-10000000,-10000000,-10000000,  1189,-10000000 };
yytabelem yypgo[]={

     0,     1,   595,   593,   592,   590,   589,   588,     3,   584,
   582,   580,   578,   567,   562,   646,   541,    52,    92,   110,
   191,   175,    71,    95,   101,    63,    67,   540,    41,     2,
   539,     6,    44,    94,   538,    35,   140,    65,   102,    97,
   126,   537,   526,    30,   524,     9,    15,   521,     8,   511,
   510,    21,     7,   597,    16,    48,    34,   509,    66,   508,
    46,   507,    40,   387,    64,    43,     4,   506,     5,   366,
   105,   470,   504,    68,    14,   501,     0,    26,   499,   497,
   496,   495,   494,   492,   491,   490,   489,   486,   484,   483,
   482,   481,   478,   475,   474,   471,   461,   442 };
yytabelem yyr1[]={

     0,     1,     3,     2,    12,    12,    12,    12,    13,    13,
    13,    13,    79,    13,    80,    13,    13,    13,    14,    14,
    15,    15,    15,    15,    15,    15,    81,    15,    15,    82,
    15,    15,    83,    15,    16,    16,    16,    16,    16,    16,
    17,    84,    17,    85,    17,    86,    17,    18,    18,    18,
    18,    19,    19,    19,    20,    20,    20,    21,    21,    21,
    21,    21,    22,    22,    22,    23,    23,    24,    24,    25,
    25,    26,    26,    27,    27,    28,    28,    29,    29,    30,
    30,    30,    30,    30,    30,    30,    30,    30,    30,    30,
    31,    31,    32,    33,    33,    34,    34,    34,    35,    35,
    35,    35,    35,    35,    35,    35,    39,    36,    87,    36,
    37,    37,    38,    38,    38,    38,    38,    40,    40,    40,
    40,    40,    40,    40,    40,    40,    40,    40,    40,    40,
    88,    41,    89,    41,    41,    42,    42,    43,    43,    44,
    44,    90,    45,    46,    46,    46,    46,    47,    91,    47,
    48,    92,    48,    48,    48,    93,    50,    94,    50,    50,
    74,    74,    49,    51,    51,    52,    52,    53,    53,    53,
    54,    54,    55,    55,    55,    55,    55,    55,    55,    77,
    56,    56,    56,    56,    57,    57,    58,    58,    59,    59,
    59,    59,    60,    60,    60,    61,    61,    62,    62,    62,
    63,    63,    64,    64,    64,    65,    65,    65,    65,    65,
    65,    65,    65,    65,    76,    66,    95,    66,    67,    67,
    68,    68,    68,    68,    68,    68,    68,     4,    96,     4,
     4,     4,     8,     8,     8,     8,    78,    69,    69,    70,
    70,    70,    70,     6,     6,     5,     5,     5,     9,     9,
     9,     9,     9,     9,     9,     9,     9,     9,     7,     7,
     7,     7,     7,     7,    10,    10,    11,    11,    71,    71,
    71,    71,    71,    71,    72,    97,    72,    73,    73,    75,
    75 };
yytabelem yyr2[]={

     0,     3,     2,     2,     2,     2,     2,     7,     2,     9,
     9,     7,     1,     9,     1,     9,     5,     5,     2,     7,
     2,     5,     5,     5,     5,     5,     1,    11,     5,     1,
    11,     5,     1,    11,     3,     3,     3,     3,     3,     3,
     2,     1,    11,     1,    13,     1,    13,     2,     7,     7,
     7,     2,     7,     7,     2,     7,     7,     2,     7,     7,
     7,     7,     2,     7,     7,     2,     7,     2,     7,     2,
     7,     2,     7,     2,     7,     2,    11,     2,     7,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     2,     7,     2,     7,     5,     7,     5,     5,     2,     2,
     2,     5,     5,     5,     2,     5,     3,     3,     1,     9,
     3,     7,     3,     3,     3,     3,     3,     3,     3,     3,
     3,     3,     3,     3,     3,     3,     3,     3,     3,     3,
     1,    13,     1,    11,     5,     3,     3,     3,     4,     2,
     7,     1,     7,     2,     2,     5,     5,     2,     1,     9,
     3,     1,     7,     7,     1,     1,    13,     1,    15,     5,
     1,     2,     3,     3,     7,     3,     7,     3,     3,     3,
     2,     5,     3,     7,     7,     9,     7,     9,     9,     3,
     3,     5,     5,     7,     2,     5,     3,     7,     3,     3,
     7,     7,     2,     3,     7,     3,     7,     5,     3,     5,
     3,     5,     2,     2,     5,     7,     5,     7,     7,     9,
     5,     7,     7,     9,     3,     2,     1,    11,     3,     7,
     2,     2,     2,     2,     2,     2,     2,     7,     1,     9,
     9,     7,     5,     7,     7,     9,     3,     3,     5,     3,
     5,     3,     4,     3,     5,    11,    15,    11,    11,    15,
    13,    15,    15,    17,    15,    17,    17,    19,     7,     5,
     5,     5,     7,     5,    15,     9,     3,     5,     2,     2,
     3,     3,    15,    11,     5,     1,     9,     2,     5,     3,
     1 };
yytabelem yychk[]={

-10000000,   -75,   -11,   -71,   -72,   -34,    59,   256,   324,   -54,
   -35,   -36,   -55,   -56,   -38,   -40,   -53,   -39,   -37,   257,
    40,    42,   286,   287,   288,   289,   290,   291,   292,   293,
   294,   295,   296,   297,   298,   299,   302,   -41,   -50,   -76,
   300,   301,   261,   338,   -42,   -49,   307,   303,   304,   305,
   -71,    40,    61,   -73,    -8,   -69,   -78,   -33,   123,   -35,
   -36,    59,   -38,   -40,   -53,   -39,   -54,    59,    44,    91,
   -77,    40,   -55,   -54,   -57,   -56,   -53,   257,   123,   -93,
   257,   264,   -66,   -29,   123,   -28,   -17,   -27,   -15,    40,
   267,   266,   -26,   -13,   -16,    38,   258,   259,   260,   -25,
   -12,    42,    43,    45,   126,    33,   -24,    -1,    -3,    -2,
   -23,   257,   262,   264,   -22,   -21,   -20,   -19,   -18,   -33,
    -8,   125,   -70,   -69,   -68,   256,    -4,    -8,    -6,    -5,
    -9,    -7,   -10,   257,   -76,   308,   309,    59,   -31,   310,
   312,   313,   314,   315,   316,   318,   319,   320,   317,   321,
   -29,   -36,    59,   -54,    59,   -97,   -87,    93,   -32,   -28,
   -17,    41,   -60,   -58,   -61,   306,    -1,   -62,   -35,    41,
   -56,   -53,   123,   -89,   123,   -94,    44,    41,   -95,   -30,
    61,   276,   277,   278,   279,   280,   281,   282,   283,   284,
   285,   272,    63,   -31,   -63,   -46,   -40,   -53,   -15,    40,
   266,   267,   -15,    40,   271,    91,    40,    46,   265,   266,
   267,   -17,   306,   -15,    40,   -15,    40,   -15,    40,   124,
    94,    38,   275,   274,   270,   273,    60,    62,   268,   269,
    43,    45,    42,    47,    37,   125,   -68,   256,   -76,   125,
   -70,    58,    58,   -32,    58,    44,    59,    40,    40,    40,
   -68,    40,   257,    59,    59,    59,   -31,    59,    -8,    59,
   -73,   -37,    93,    41,    41,    44,    44,   -54,   -64,   -56,
   -65,    40,    91,   -77,   -88,   -43,   -44,   -45,   -46,   -51,
   -52,   257,   123,   -59,    -1,   264,   -58,    59,   -67,   -66,
   -29,   -26,   -31,    41,   -84,   -40,   -53,   -64,   -56,    40,
   -63,    40,   -63,   -25,   -31,   -14,    41,   -29,   -79,   -80,
   -63,   -63,   -63,   -24,   -23,   -22,   -21,   -21,   -20,   -20,
   -20,   -20,   -19,   -19,   -18,   -18,   -17,   -17,   -17,   125,
   -68,   -96,    58,   -68,   -29,   -31,   -31,   -31,   313,    59,
   -31,    59,    59,   322,   323,    -1,   306,   -62,   -65,    91,
   -77,   -64,    93,   -32,    41,   -60,   -43,   125,    59,   -90,
   -74,    44,    61,   -51,    41,    44,   -74,    44,    58,    41,
   -85,   -86,    93,    41,    44,    -1,    -1,   -81,   -82,   -83,
   -68,   -68,    41,    41,    41,    40,    59,   -31,    59,    40,
    -8,    93,   -32,    41,   -60,    41,    93,    41,   125,   -45,
   -47,   -48,   -54,    58,   125,   -52,   -32,   -74,    59,    -1,
   264,   125,   -66,   -28,   -17,    41,    41,   -29,    41,    41,
    41,   -68,   -68,   -68,   -31,    41,   -31,    59,    59,   -31,
   -31,    93,    41,    44,    58,   -92,   125,   -17,   -17,   311,
    41,   -68,    41,    41,   -31,    41,   -31,    59,    41,   -91,
   -32,   -32,   -68,    59,   -68,   -68,    41,   -68,    41,    41,
   -31,    -8,   -48,   -68,   -68,   -68,    41,   -68 };
yytabelem yydef[]={

    -2,    -2,    -2,   266,   268,   269,   270,   271,     0,   110,
     0,     0,   170,     0,    98,    99,   100,   104,   107,   172,
     0,   180,   112,   113,   114,   115,   116,   117,   118,   119,
   120,   121,   122,   123,   124,   125,   126,   127,   128,   129,
   167,   168,   169,   106,     0,   155,   214,   135,   136,   162,
   267,     0,     0,   274,   277,     0,     0,   237,   236,     0,
     0,    96,   101,   102,   103,   105,    -2,    97,   108,     0,
     0,   179,   171,     0,   181,   182,   184,   134,   132,     0,
    -2,     0,   111,   215,   216,    77,    47,    75,    40,     0,
     0,     0,    73,    20,     0,    34,     0,     0,     0,    71,
     8,    35,    36,    37,    38,    39,    69,     4,     5,     6,
    67,     1,     2,     3,    65,    62,    57,    54,    51,   238,
   278,   232,     0,     0,   239,   241,   220,   221,   222,   223,
   224,   225,   226,     1,   129,     0,     0,   243,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
    90,     0,    94,   110,    95,     0,     0,   174,     0,    92,
    47,   176,     0,     0,   192,   193,   186,   195,   198,   173,
   183,   185,   130,     0,     0,     0,     0,     0,     0,     0,
    79,    80,    81,    82,    83,    84,    85,    86,    87,    88,
    89,     0,     0,     0,    41,   200,   143,   144,    22,     0,
     0,     0,    21,     0,     0,     0,     0,    12,    14,    16,
    17,    23,    24,    25,     0,    28,     0,    31,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   233,   240,   242,     0,   234,
     0,     0,   228,     0,     0,     0,   244,     0,     0,     0,
     0,     0,     0,   259,   260,   261,     0,   263,     0,    93,
   276,   109,   175,   177,   178,     0,     0,   197,   199,   202,
   203,   179,     0,     0,     0,     0,   137,   139,   141,   160,
   163,   165,     0,     0,    -2,   189,     0,   273,   160,   218,
    78,    74,     0,     7,     0,   145,   146,   201,   202,   179,
    43,     0,    45,    72,     0,     0,    11,    18,     0,     0,
    26,    29,    32,    70,    68,    66,    63,    64,    58,    59,
    60,    61,    55,    56,    52,    53,    48,    49,    50,   235,
   227,     0,     0,   231,    91,     0,     0,     0,     0,     0,
     0,   258,   262,     0,     0,   187,   194,   196,   204,     0,
     0,     0,   206,     0,   210,     0,     0,   133,   138,   154,
     0,   161,     0,   160,     0,     0,     0,   161,     0,     0,
     0,     0,     9,    10,     0,    13,    15,     0,     0,     0,
   229,   230,     0,     0,     0,     0,     0,     0,     0,     0,
   265,   208,     0,   212,     0,   205,   207,   211,   131,   140,
   142,   147,   150,   151,   156,   164,   166,     0,   272,    -2,
   191,   217,   219,    76,    42,     0,     0,    19,    27,    30,
    33,   245,   247,   248,     0,     0,     0,     0,     0,     0,
     0,   209,   213,   148,     0,     0,   158,    44,    46,     0,
     0,   250,     0,     0,     0,     0,     0,     0,     0,   154,
   153,   152,   246,   249,   251,   252,     0,   254,     0,     0,
     0,   264,   149,   253,   255,   256,     0,   257 };
typedef struct
#ifdef __cplusplus
	yytoktype
#endif
{ char *t_name; int t_val; } yytoktype;
#ifndef YYDEBUG
#	define YYDEBUG	1	/* allow debugging */
#endif

#if YYDEBUG

yytoktype yytoks[] =
{
	"IDENTIFIER",	257,
	"SIZEOF",	258,
	"ALIGNOF",	259,
	"CLASSOF",	260,
	"UNALIGN",	261,
	"STRING",	262,
	"WSTRING",	263,
	"CONSTANT",	264,
	"PTR_OP",	265,
	"INC_OP",	266,
	"DEC_OP",	267,
	"LEFT_OP",	268,
	"RIGHT_OP",	269,
	"LE_OP",	270,
	"AND_OP",	271,
	"OR_OP",	272,
	"GE_OP",	273,
	"NE_OP",	274,
	"EQ_OP",	275,
	"MUL_ASSIGN",	276,
	"DIV_ASSIGN",	277,
	"REM_ASSIGN",	278,
	"ADD_ASSIGN",	279,
	"SUB_ASSIGN",	280,
	"LEFT_ASSIGN",	281,
	"RIGHT_ASSIGN",	282,
	"AND_ASSIGN",	283,
	"XOR_ASSIGN",	284,
	"OR_ASSIGN",	285,
	"TYPEDEF",	286,
	"EXTERN",	287,
	"STATIC",	288,
	"AUTO",	289,
	"REGISTER",	290,
	"CHAR",	291,
	"SHORT",	292,
	"INT",	293,
	"LONG",	294,
	"LONGLONG",	295,
	"SIGNED",	296,
	"UNSIGNED",	297,
	"FLOAT",	298,
	"DOUBLE",	299,
	"CONST",	300,
	"VOLATILE",	301,
	"VOID",	302,
	"STRUCT",	303,
	"UNION",	304,
	"ENUM",	305,
	"ELLIPSIS",	306,
	"TYPE_IDENT",	307,
	"CASE",	308,
	"DEFAULT",	309,
	"IF",	310,
	"ELSE",	311,
	"SWITCH",	312,
	"WHILE",	313,
	"DO",	314,
	"FOR",	315,
	"GOTO",	316,
	"LEAVE",	317,
	"CONTINUE",	318,
	"BREAK",	319,
	"RETURN",	320,
	"TRY",	321,
	"EXCEPT",	322,
	"FINALLY",	323,
	"__PRAGMA",	324,
	"(",	40,
	")",	41,
	"{",	123,
	"}",	125,
	"[",	91,
	"]",	93,
	"?",	63,
	":",	58,
	"~",	126,
	",",	44,
	";",	59,
	"+",	43,
	"-",	45,
	"/",	47,
	"%",	37,
	"&",	38,
	"|",	124,
	"^",	94,
	"!",	33,
	"=",	61,
	"*",	42,
	".",	46,
	"<",	60,
	">",	62,
	"CLASS",	325,
	"VIRTUAL",	326,
	"PROTECTED",	327,
	"PUBLIC",	328,
	"PRIVATE",	329,
	"COLONCOLON",	330,
	"COLCOLSTAR",	331,
	"OPERATOR",	332,
	"THIS",	333,
	"MEMDOT_OP",	334,
	"MEMPTR_OP",	335,
	"NEW",	336,
	"DELETE",	337,
	"INLINE",	338,
	"FRIEND",	339,
	"-unknown-",	-1	/* ends search */
};

char * yyreds[] =
{
	"-no such reduction-",
	"identifier : IDENTIFIER",
	"string_literal : STRING",
	"constant : CONSTANT",
	"primary_expression : identifier",
	"primary_expression : string_literal",
	"primary_expression : constant",
	"primary_expression : '(' expression ')'",
	"postfix_expression : primary_expression",
	"postfix_expression : postfix_expression '[' expression ']'",
	"postfix_expression : postfix_expression '(' argument_expression_list ')'",
	"postfix_expression : postfix_expression '(' ')'",
	"postfix_expression : postfix_expression '.'",
	"postfix_expression : postfix_expression '.' identifier",
	"postfix_expression : postfix_expression PTR_OP",
	"postfix_expression : postfix_expression PTR_OP identifier",
	"postfix_expression : postfix_expression INC_OP",
	"postfix_expression : postfix_expression DEC_OP",
	"argument_expression_list : assignment_expression",
	"argument_expression_list : argument_expression_list ',' assignment_expression",
	"unary_expression : postfix_expression",
	"unary_expression : INC_OP unary_expression",
	"unary_expression : DEC_OP unary_expression",
	"unary_expression : unary_operator cast_expression",
	"unary_expression : '&' ELLIPSIS",
	"unary_expression : SIZEOF unary_expression",
	"unary_expression : SIZEOF '(' type_name",
	"unary_expression : SIZEOF '(' type_name ')'",
	"unary_expression : ALIGNOF unary_expression",
	"unary_expression : ALIGNOF '(' type_name",
	"unary_expression : ALIGNOF '(' type_name ')'",
	"unary_expression : CLASSOF unary_expression",
	"unary_expression : CLASSOF '(' type_name",
	"unary_expression : CLASSOF '(' type_name ')'",
	"unary_operator : '&'",
	"unary_operator : '*'",
	"unary_operator : '+'",
	"unary_operator : '-'",
	"unary_operator : '~'",
	"unary_operator : '!'",
	"cast_expression : unary_expression",
	"cast_expression : '(' type_name",
	"cast_expression : '(' type_name ')' cast_expression",
	"cast_expression : DEC_OP '(' type_name",
	"cast_expression : DEC_OP '(' type_name ')' cast_expression",
	"cast_expression : INC_OP '(' type_name",
	"cast_expression : INC_OP '(' type_name ')' cast_expression",
	"multiplicative_expression : cast_expression",
	"multiplicative_expression : multiplicative_expression '*' cast_expression",
	"multiplicative_expression : multiplicative_expression '/' cast_expression",
	"multiplicative_expression : multiplicative_expression '%' cast_expression",
	"additive_expression : multiplicative_expression",
	"additive_expression : additive_expression '+' multiplicative_expression",
	"additive_expression : additive_expression '-' multiplicative_expression",
	"shift_expression : additive_expression",
	"shift_expression : shift_expression LEFT_OP additive_expression",
	"shift_expression : shift_expression RIGHT_OP additive_expression",
	"relational_expression : shift_expression",
	"relational_expression : relational_expression LE_OP shift_expression",
	"relational_expression : relational_expression GE_OP shift_expression",
	"relational_expression : relational_expression '<' shift_expression",
	"relational_expression : relational_expression '>' shift_expression",
	"equality_expression : relational_expression",
	"equality_expression : equality_expression EQ_OP relational_expression",
	"equality_expression : equality_expression NE_OP relational_expression",
	"AND_expression : equality_expression",
	"AND_expression : AND_expression '&' equality_expression",
	"exclusive_OR_expression : AND_expression",
	"exclusive_OR_expression : exclusive_OR_expression '^' AND_expression",
	"inclusive_OR_expression : exclusive_OR_expression",
	"inclusive_OR_expression : inclusive_OR_expression '|' exclusive_OR_expression",
	"logical_AND_expression : inclusive_OR_expression",
	"logical_AND_expression : logical_AND_expression AND_OP inclusive_OR_expression",
	"logical_OR_expression : logical_AND_expression",
	"logical_OR_expression : logical_OR_expression OR_OP logical_AND_expression",
	"conditional_expression : logical_OR_expression",
	"conditional_expression : logical_OR_expression '?' expression ':' conditional_expression",
	"assignment_expression : conditional_expression",
	"assignment_expression : cast_expression assignment_operator assignment_expression",
	"assignment_operator : '='",
	"assignment_operator : MUL_ASSIGN",
	"assignment_operator : DIV_ASSIGN",
	"assignment_operator : REM_ASSIGN",
	"assignment_operator : ADD_ASSIGN",
	"assignment_operator : SUB_ASSIGN",
	"assignment_operator : LEFT_ASSIGN",
	"assignment_operator : RIGHT_ASSIGN",
	"assignment_operator : AND_ASSIGN",
	"assignment_operator : XOR_ASSIGN",
	"assignment_operator : OR_ASSIGN",
	"expression : assignment_expression",
	"expression : expression ',' assignment_expression",
	"constant_expression : conditional_expression",
	"declaration : declaration_specifiers init_declarator_list ';'",
	"declaration : declaration_specifiers ';'",
	"top_declaration : declaration_specifiers init_declarator_list ';'",
	"top_declaration : declaration_specifiers ';'",
	"top_declaration : init_declarator_list ';'",
	"declaration_specifiers : storage_class_specifier",
	"declaration_specifiers : type_specifier",
	"declaration_specifiers : type_qualifier",
	"declaration_specifiers : declaration_specifiers storage_class_specifier",
	"declaration_specifiers : declaration_specifiers type_specifier",
	"declaration_specifiers : declaration_specifiers type_qualifier",
	"declaration_specifiers : fct_specifier",
	"declaration_specifiers : declaration_specifiers fct_specifier",
	"fct_specifier : INLINE",
	"init_declarator_list : init_declarator",
	"init_declarator_list : init_declarator_list ','",
	"init_declarator_list : init_declarator_list ',' init_declarator",
	"init_declarator : declarator",
	"init_declarator : declarator '=' initializer",
	"storage_class_specifier : TYPEDEF",
	"storage_class_specifier : EXTERN",
	"storage_class_specifier : STATIC",
	"storage_class_specifier : AUTO",
	"storage_class_specifier : REGISTER",
	"type_specifier : CHAR",
	"type_specifier : SHORT",
	"type_specifier : INT",
	"type_specifier : LONG",
	"type_specifier : LONGLONG",
	"type_specifier : SIGNED",
	"type_specifier : UNSIGNED",
	"type_specifier : FLOAT",
	"type_specifier : DOUBLE",
	"type_specifier : VOID",
	"type_specifier : struct_or_union_specifier",
	"type_specifier : enum_specifier",
	"type_specifier : typedef_name",
	"struct_or_union_specifier : struct_or_union IDENTIFIER '{'",
	"struct_or_union_specifier : struct_or_union IDENTIFIER '{' struct_declaration_list_semi '}'",
	"struct_or_union_specifier : struct_or_union '{'",
	"struct_or_union_specifier : struct_or_union '{' struct_declaration_list_semi '}'",
	"struct_or_union_specifier : struct_or_union IDENTIFIER",
	"struct_or_union : STRUCT",
	"struct_or_union : UNION",
	"struct_declaration_list_semi : struct_declaration_list",
	"struct_declaration_list_semi : struct_declaration_list ';'",
	"struct_declaration_list : struct_declaration",
	"struct_declaration_list : struct_declaration_list ';' struct_declaration",
	"struct_declaration : specifier_qualifier_list",
	"struct_declaration : specifier_qualifier_list struct_declarator_list",
	"specifier_qualifier_list : type_specifier",
	"specifier_qualifier_list : type_qualifier",
	"specifier_qualifier_list : specifier_qualifier_list type_specifier",
	"specifier_qualifier_list : specifier_qualifier_list type_qualifier",
	"struct_declarator_list : struct_declarator",
	"struct_declarator_list : struct_declarator_list ','",
	"struct_declarator_list : struct_declarator_list ',' struct_declarator",
	"struct_declarator : declarator",
	"struct_declarator : ':'",
	"struct_declarator : ':' constant_expression",
	"struct_declarator : declarator ':' constant_expression",
	"struct_declarator : /* empty */",
	"enum_specifier : enum",
	"enum_specifier : enum '{' enumerator_list optcomma '}'",
	"enum_specifier : enum IDENTIFIER",
	"enum_specifier : enum IDENTIFIER '{' enumerator_list optcomma '}'",
	"enum_specifier : enum IDENTIFIER",
	"optcomma : /* empty */",
	"optcomma : ','",
	"enum : ENUM",
	"enumerator_list : enumerator",
	"enumerator_list : enumerator_list ',' enumerator",
	"enumerator : IDENTIFIER",
	"enumerator : IDENTIFIER '=' constant_expression",
	"type_qualifier : CONST",
	"type_qualifier : VOLATILE",
	"type_qualifier : UNALIGN",
	"declarator : direct_declarator",
	"declarator : pointer direct_declarator",
	"direct_declarator : IDENTIFIER",
	"direct_declarator : '(' declarator ')'",
	"direct_declarator : direct_declarator '[' ']'",
	"direct_declarator : direct_declarator '[' constant_expression ']'",
	"direct_declarator : direct_declarator fdecl_start ')'",
	"direct_declarator : direct_declarator fdecl_start parameter_type_list ')'",
	"direct_declarator : direct_declarator fdecl_start identifier_list ')'",
	"fdecl_start : '('",
	"pointer : '*'",
	"pointer : '*' type_qualifier_list",
	"pointer : '*' pointer",
	"pointer : '*' type_qualifier_list pointer",
	"type_qualifier_list : type_qualifier",
	"type_qualifier_list : type_qualifier_list type_qualifier",
	"identifier_list : identifier",
	"identifier_list : identifier_list ',' identifier",
	"identifier_or_constant_list : identifier",
	"identifier_or_constant_list : CONSTANT",
	"identifier_or_constant_list : identifier_list ',' identifier",
	"identifier_or_constant_list : identifier_list ',' CONSTANT",
	"parameter_type_list : parameter_list",
	"parameter_type_list : ELLIPSIS",
	"parameter_type_list : parameter_list ',' ELLIPSIS",
	"parameter_list : parameter_declaration",
	"parameter_list : parameter_list ',' parameter_declaration",
	"parameter_declaration : declaration_specifiers declarator",
	"parameter_declaration : declaration_specifiers",
	"parameter_declaration : declaration_specifiers abstract_declarator",
	"type_name : specifier_qualifier_list",
	"type_name : specifier_qualifier_list abstract_declarator",
	"abstract_declarator : pointer",
	"abstract_declarator : direct_abstract_declarator",
	"abstract_declarator : pointer direct_abstract_declarator",
	"direct_abstract_declarator : '(' abstract_declarator ')'",
	"direct_abstract_declarator : '[' ']'",
	"direct_abstract_declarator : '[' constant_expression ']'",
	"direct_abstract_declarator : direct_abstract_declarator '[' ']'",
	"direct_abstract_declarator : direct_abstract_declarator '[' constant_expression ']'",
	"direct_abstract_declarator : fdecl_start ')'",
	"direct_abstract_declarator : fdecl_start parameter_type_list ')'",
	"direct_abstract_declarator : direct_abstract_declarator fdecl_start ')'",
	"direct_abstract_declarator : direct_abstract_declarator fdecl_start parameter_type_list ')'",
	"typedef_name : TYPE_IDENT",
	"initializer : assignment_expression",
	"initializer : '{'",
	"initializer : '{' initializer_list optcomma '}'",
	"initializer_list : initializer",
	"initializer_list : initializer_list ',' initializer",
	"statement : labeled_statement",
	"statement : compound_statement",
	"statement : expression_statement",
	"statement : selection_statement",
	"statement : iteration_statement",
	"statement : jump_statement",
	"statement : try_statement",
	"labeled_statement : IDENTIFIER ':' statement",
	"labeled_statement : typedef_name ':'",
	"labeled_statement : typedef_name ':' statement",
	"labeled_statement : CASE constant_expression ':' statement",
	"labeled_statement : DEFAULT ':' statement",
	"compound_statement : comp_start '}'",
	"compound_statement : comp_start statement_list '}'",
	"compound_statement : comp_start declaration_list '}'",
	"compound_statement : comp_start declaration_list statement_list '}'",
	"comp_start : '{'",
	"declaration_list : declaration",
	"declaration_list : declaration_list declaration",
	"statement_list : statement",
	"statement_list : statement_list statement",
	"statement_list : error",
	"statement_list : statement_list error",
	"expression_statement : ';'",
	"expression_statement : expression ';'",
	"selection_statement : IF '(' expression ')' statement",
	"selection_statement : IF '(' expression ')' statement ELSE statement",
	"selection_statement : SWITCH '(' expression ')' statement",
	"iteration_statement : WHILE '(' expression ')' statement",
	"iteration_statement : DO statement WHILE '(' expression ')' ';'",
	"iteration_statement : FOR '(' ';' ';' ')' statement",
	"iteration_statement : FOR '(' ';' ';' expression ')' statement",
	"iteration_statement : FOR '(' ';' expression ';' ')' statement",
	"iteration_statement : FOR '(' ';' expression ';' expression ')' statement",
	"iteration_statement : FOR '(' expression ';' ';' ')' statement",
	"iteration_statement : FOR '(' expression ';' ';' expression ')' statement",
	"iteration_statement : FOR '(' expression ';' expression ';' ')' statement",
	"iteration_statement : FOR '(' expression ';' expression ';' expression ')' statement",
	"jump_statement : GOTO IDENTIFIER ';'",
	"jump_statement : CONTINUE ';'",
	"jump_statement : BREAK ';'",
	"jump_statement : RETURN ';'",
	"jump_statement : RETURN expression ';'",
	"jump_statement : LEAVE ';'",
	"try_statement : TRY compound_statement EXCEPT '(' expression ')' compound_statement",
	"try_statement : TRY compound_statement FINALLY compound_statement",
	"translation_unit : external_definition",
	"translation_unit : translation_unit external_definition",
	"external_definition : function_definition",
	"external_definition : top_declaration",
	"external_definition : ';'",
	"external_definition : error",
	"external_definition : __PRAGMA '(' CONSTANT ',' identifier_or_constant_list ')' ';'",
	"external_definition : __PRAGMA '(' CONSTANT ')' ';'",
	"function_definition : declarator function_body",
	"function_definition : declaration_specifiers declarator",
	"function_definition : declaration_specifiers declarator function_body",
	"function_body : compound_statement",
	"function_body : declaration_list compound_statement",
	"build_program_tree : translation_unit",
	"build_program_tree : /* empty */",
};
#endif /* YYDEBUG */
/* 
 *	Copyright 1987 Silicon Graphics, Inc. - All Rights Reserved
 */

/* #ident	"@(#)yacc:yaccpar	1.10" */
#ident	"$Revision: 1.10 $"

/*
** Skeleton parser driver for yacc output
*/
#include "stddef.h"

/*
** yacc user known macros and defines
*/
#define YYERROR		goto yyerrlab
#define YYACCEPT	return(0)
#define YYABORT		return(1)
#ifdef __cplusplus
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
	{\
		yyerror( gettxt("uxlibc:78", "syntax error - cannot backup") );\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	yystate = *yyps;\
	yylval = newvalue;\
	goto yynewstate;\
}
#else
#define YYBACKUP( newtoken, newvalue )\
{\
	if ( yychar >= 0 || ( yyr2[ yytmp ] >> 1 ) != 1 )\
	{\
		yyerror( gettxt("uxlibc:78", "Syntax error - cannot backup") );\
		goto yyerrlab;\
	}\
	yychar = newtoken;\
	yystate = *yyps;\
	yylval = newvalue;\
	goto yynewstate;\
}
#endif
#define YYRECOVERING()	(!!yyerrflag)
#define YYNEW(type)	malloc(sizeof(type) * yynewmax)
#define YYCOPY(to, from, type) \
	(type *) memcpy(to, (char *) from, yynewmax * sizeof(type))
#define YYENLARGE( from, type) \
	(type *) realloc((char *) from, yynewmax * sizeof(type))
#ifndef YYDEBUG
#	define YYDEBUG	1	/* make debugging available */
#endif

/*
** user known globals
*/
int yydebug;			/* set to 1 to get debugging */

/*
** driver internal defines
*/
#define YYFLAG		(-10000000)

/*
** global variables used by the parser
*/
YYSTYPE *yypv;			/* top of value stack */
int *yyps;			/* top of state stack */

int yystate;			/* current state */
int yytmp;			/* extra var (lasts between blocks) */

int yynerrs;			/* number of errors */
int yyerrflag;			/* error recovery flag */
int yychar;			/* current input token number */



/*
** yyparse - return 0 if worked, 1 if syntax error not recovered from
*/
#if defined(__STDC__) || defined(__cplusplus)
int yyparse(void)
#else
int yyparse()
#endif
{
	register YYSTYPE *yypvt;	/* top of value stack for $vars */

	/*
	** Initialize externals - yyparse may be called more than once
	*/
	yypv = &yyv[-1];
	yyps = &yys[-1];
	yystate = 0;
	yytmp = 0;
	yynerrs = 0;
	yyerrflag = 0;
	yychar = -1;

#if YYMAXDEPTH <= 0
	if (yymaxdepth <= 0)
	{
		if ((yymaxdepth = YYEXPAND(0)) <= 0)
		{
#ifdef __cplusplus
			yyerror(gettxt("uxlibc:79", "yacc initialization error"));
#else
			yyerror(gettxt("uxlibc:79", "Yacc initialization error"));
#endif
			YYABORT;
		}
	}
#endif

	goto yystack;
	{
		register YYSTYPE *yy_pv;	/* top of value stack */
		register int *yy_ps;		/* top of state stack */
		register int yy_state;		/* current state */
		register int  yy_n;		/* internal state number info */

		/*
		** get globals into registers.
		** branch to here only if YYBACKUP was called.
		*/
	yynewstate:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;
		goto yy_newstate;

		/*
		** get globals into registers.
		** either we just started, or we just finished a reduction
		*/
	yystack:
		yy_pv = yypv;
		yy_ps = yyps;
		yy_state = yystate;

		/*
		** top of for (;;) loop while no reductions done
		*/
	yy_stack:
		/*
		** put a state and value onto the stacks
		*/
#if YYDEBUG
		/*
		** if debugging, look up token value in list of value vs.
		** name pairs.  0 and negative (-1) are special values.
		** Note: linear search is used since time is not a real
		** consideration while debugging.
		*/
		if ( yydebug )
		{
			register int yy_i;

			printf( "State %d, token ", yy_state );
			if ( yychar == 0 )
				printf( "end-of-file\n" );
			else if ( yychar < 0 )
				printf( "-none-\n" );
			else if ( yychar < 0x100 )
				printf( "%c\n", yychar );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ++yy_ps >= &yys[ yymaxdepth ] )	/* room on stack? */
		{
			int yynewmax;
			ptrdiff_t yys_off;

			/* The following pointer-differences are safe, since
			 * yypvt, yy_pv, and yypv all are a multiple of
			 * sizeof(YYSTYPE) bytes from yyv.
			 */
			ptrdiff_t yypvt_off = yypvt - yyv;
			ptrdiff_t yy_pv_off = yy_pv - yyv;
			ptrdiff_t yypv_off = yypv - yyv;

			int *yys_base = yys;
#ifdef YYEXPAND
			yynewmax = YYEXPAND(yymaxdepth);
#else
			yynewmax = 2 * yymaxdepth;	/* double table size */
			if (yymaxdepth == YYMAXDEPTH)	/* first time growth */
			{
				void *newyys = YYNEW(int);
				void *newyyv = YYNEW(YYSTYPE);
				if (newyys != 0 && newyyv != 0)
				{
					yys = YYCOPY(newyys, yys, int);
					yyv = YYCOPY(newyyv, yyv, YYSTYPE);
				}
				else
					yynewmax = 0;	/* failed */
			}
			else				/* not first time */
			{
				yys = YYENLARGE(yys, int);
				yyv = YYENLARGE(yyv, YYSTYPE);
				if (yys == 0 || yyv == 0)
					yynewmax = 0;	/* failed */
			}
#endif
			if (yynewmax <= yymaxdepth)	/* tables not expanded */
			{
#ifdef __cplusplus
				error(0x2007D, LEVEL_ERROR, curloc);
#else
				error(0x2007D, LEVEL_ERROR, curloc);
#endif
				YYABORT;
			}
			yymaxdepth = yynewmax;

			/* reset pointers into yys */
			yys_off = yys - yys_base;
			yy_ps = yy_ps + yys_off;
			yyps = yyps + yys_off;

			/* reset pointers into yyv */
			yypvt = yyv + yypvt_off;
			yy_pv = yyv + yy_pv_off;
			yypv = yyv + yypv_off;
		}
		*yy_ps = yy_state;
		*++yy_pv = yyval;

		/*
		** we have a new state - find out what to do
		*/
	yy_newstate:
		if ( ( yy_n = yypact[ yy_state ] ) <= YYFLAG )
			goto yydefault;		/* simple state */
#if YYDEBUG
		/*
		** if debugging, need to mark whether new token grabbed
		*/
		yytmp = yychar < 0;
#endif
		if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
			yychar = 0;		/* reached EOF */
#if YYDEBUG
		if ( yydebug && yytmp )
		{
			register int yy_i;

			printf( "Received token " );
			if ( yychar == 0 )
				printf( "end-of-file\n" );
			else if ( yychar < 0 )
				printf( "-none-\n" );
			else if ( yychar < 0x100 )
				printf( "%c\n", yychar );
			else
			{
				for ( yy_i = 0; yytoks[yy_i].t_val >= 0;
					yy_i++ )
				{
					if ( yytoks[yy_i].t_val == yychar )
						break;
				}
				printf( "%s\n", yytoks[yy_i].t_name );
			}
		}
#endif /* YYDEBUG */
		if ( ( ( yy_n += yychar ) < 0 ) || ( yy_n >= YYLAST ) )
			goto yydefault;
		if ( yychk[ yy_n = yyact[ yy_n ] ] == yychar )	/*valid shift*/
		{
			yychar = -1;
			yyval = yylval;
			yy_state = yy_n;
			if ( yyerrflag > 0 )
				yyerrflag--;
			goto yy_stack;
		}

	yydefault:
		if ( ( yy_n = yydef[ yy_state ] ) == -2 )
		{
#if YYDEBUG
			yytmp = yychar < 0;
#endif
			if ( ( yychar < 0 ) && ( ( yychar = yylex() ) < 0 ) )
				yychar = 0;		/* reached EOF */
#if YYDEBUG
			if ( yydebug && yytmp )
			{
				register int yy_i;

				printf( "Received token " );
				if ( yychar == 0 )
					printf( "end-of-file\n" );
				else if ( yychar < 0 )
					printf( "-none-\n" );
				else if ( yychar < 0x100 )
					printf( "%c\n", yychar );
				else
				{
					for ( yy_i = 0;
						yytoks[yy_i].t_val >= 0;
						yy_i++ )
					{
						if ( yytoks[yy_i].t_val
							== yychar )
						{
							break;
						}
					}
					printf( "%s\n", yytoks[yy_i].t_name );
				}
			}
#endif /* YYDEBUG */
			/*
			** look through exception table
			*/
			{
				register int *yyxi = yyexca;

				while ( ( *yyxi != -1 ) ||
					( yyxi[1] != yy_state ) )
				{
					yyxi += 2;
				}
				while ( ( *(yyxi += 2) >= 0 ) &&
					( *yyxi != yychar ) )
					;
				if ( ( yy_n = yyxi[1] ) < 0 )
					YYACCEPT;
			}
		}

		/*
		** check for syntax error
		*/
		if ( yy_n == 0 )	/* have an error */
		{
			/* no worry about speed here! */
			switch ( yyerrflag )
			{
			case 0:		/* new error */
#ifdef __cplusplus
				error(0x2007B, LEVEL_ERROR, curloc);
#else
				error(0x2007B, LEVEL_ERROR, curloc);
#endif
				goto skip_init;
			yyerrlab:
				/*
				** get globals into registers.
				** we have a user generated syntax type error
				*/
				yy_pv = yypv;
				yy_ps = yyps;
				yy_state = yystate;
				yynerrs++;
				/* FALLTHRU */
			skip_init:
			case 1:
			case 2:		/* incompletely recovered error */
					/* try again... */
				yyerrflag = 3;
				/*
				** find state where "error" is a legal
				** shift action
				*/
				while ( yy_ps >= yys )
				{
					yy_n = yypact[ *yy_ps ] + YYERRCODE;
					if ( yy_n >= 0 && yy_n < YYLAST &&
						yychk[yyact[yy_n]] == YYERRCODE)					{
						/*
						** simulate shift of "error"
						*/
						yy_state = yyact[ yy_n ];
						goto yy_stack;
					}
					/*
					** current state has no shift on
					** "error", pop stack
					*/
#if YYDEBUG
#	define _POP_ "Error recovery pops state %d, uncovers state %d\n"
					if ( yydebug )
						printf( _POP_, *yy_ps,
							yy_ps[-1] );
#	undef _POP_
#endif
					yy_ps--;
					yy_pv--;
				}
				/*
				** there is no state on stack with "error" as
				** a valid shift.  give up.
				*/
				YYABORT;
			case 3:		/* no shift yet; eat a token */
#if YYDEBUG
				/*
				** if debugging, look up token in list of
				** pairs.  0 and negative shouldn't occur,
				** but since timing doesn't matter when
				** debugging, it doesn't hurt to leave the
				** tests here.
				*/
				if ( yydebug )
				{
					register int yy_i;

					printf( "Error recovery discards " );
					if ( yychar == 0 )
						printf( "token end-of-file\n" );
					else if ( yychar < 0 )
						printf( "token -none-\n" );
					else
					{
						for ( yy_i = 0;
							yytoks[yy_i].t_val >= 0;
							yy_i++ )
						{
							if ( yytoks[yy_i].t_val
								== yychar )
							{
								break;
							}
						}
						printf( "token %s\n",
							yytoks[yy_i].t_name );
					}
				}
#endif /* YYDEBUG */
				if ( yychar == 0 )	/* reached EOF. quit */
					YYABORT;
				yychar = -1;
				goto yy_newstate;
			}
		}/* end if ( yy_n == 0 ) */
		/*
		** reduction by production yy_n
		** put stack tops, etc. so things right after switch
		*/
#if YYDEBUG
		/*
		** if debugging, print the string that is the user's
		** specification of the reduction which is just about
		** to be done.
		*/
		if ( yydebug )
			printf( "Reduce by (%d) \"%s\"\n",
				yy_n, yyreds[ yy_n ] );
#endif
		yytmp = yy_n;			/* value to switch over */
		yypvt = yy_pv;			/* $vars top of value stack */
		/*
		** Look in goto table for next state
		** Sorry about using yy_state here as temporary
		** register variable, but why not, if it works...
		** If yyr2[ yy_n ] doesn't have the low order bit
		** set, then there is no action to be done for
		** this reduction.  So, no saving & unsaving of
		** registers done.  The only difference between the
		** code just after the if and the body of the if is
		** the goto yy_stack in the body.  This way the test
		** can be made before the choice of what to do is needed.
		*/
		{
			/* length of production doubled with extra bit */
			register int yy_len = yyr2[ yy_n ];

			if ( !( yy_len & 01 ) )
			{
				yy_len >>= 1;
				yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
				yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
					*( yy_ps -= yy_len ) + 1;
				if ( yy_state >= YYLAST ||
					yychk[ yy_state =
					yyact[ yy_state ] ] != -yy_n )
				{
					yy_state = yyact[ yypgo[ yy_n ] ];
				}
				goto yy_stack;
			}
			yy_len >>= 1;
			yyval = ( yy_pv -= yy_len )[1];	/* $$ = $1 */
			yy_state = yypgo[ yy_n = yyr1[ yy_n ] ] +
				*( yy_ps -= yy_len ) + 1;
			if ( yy_state >= YYLAST ||
				yychk[ yy_state = yyact[ yy_state ] ] != -yy_n )
			{
				yy_state = yyact[ yypgo[ yy_n ] ];
			}
		}
					/* save until reenter driver code */
		yystate = yy_state;
		yyps = yy_ps;
		yypv = yy_pv;
	}
	/*
	** code supplied by user is placed in this switch
	*/
	switch( yytmp )
	{
		
case 1:
# line 295 "src/7.1/cfe/c.y"
{
		if (debug_arr['y'] > 0) {
			fprintf(dbgout, "IDENT=%s, was_typedef=%d\n", yypvt[-0].identifier.symbol->name, yypvt[-0].identifier.was_typedef);
		}
		yyval.node = make(Identifier, yypvt[-0].identifier.location, yypvt[-0].identifier.symbol);
	} break;
case 7:
# line 315 "src/7.1/cfe/c.y"
{ yyval.node = yypvt[-1].node; } break;
case 9:
# line 320 "src/7.1/cfe/c.y"
{ yyval.node = make(Index_expr, yypvt[-2].location, yypvt[-3].node, yypvt[-1].node); } break;
case 10:
# line 322 "src/7.1/cfe/c.y"
{ 
			TreeNode* sp108 = make(Aggregate_expr, TREE_LOCATION(yypvt[-1].node), yypvt[-1].node);
			yyval.node = make(Call_expr, yypvt[-2].location, yypvt[-3].node, sp108);
		} break;
case 11:
# line 326 "src/7.1/cfe/c.y"
{ yyval.node = make(Call_expr, yypvt[-1].location, yypvt[-2].node, NULL); } break;
case 12:
# line 327 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 0; } break;
case 13:
# line 328 "src/7.1/cfe/c.y"
{ 
			yyval.node = make(Component_ref, yypvt[-2].location, yypvt[-3].node, yypvt[-0].node);
			cur_lvl->unk_04 = 1;
		} break;
case 14:
# line 332 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 0; } break;
case 15:
# line 333 "src/7.1/cfe/c.y"
{
			yyval.node = make(Indirect_component_ref, yypvt[-2].location, yypvt[-3].node, yypvt[-0].node);
			cur_lvl->unk_04 = 1;
		} break;
case 16:
# line 337 "src/7.1/cfe/c.y"
{ yyval.node = make(Postincrement_expr, yypvt[-0].location, yypvt[-1].node); } break;
case 17:
# line 338 "src/7.1/cfe/c.y"
{ yyval.node = make(Postdecrement_expr, yypvt[-0].location, yypvt[-1].node); } break;
case 19:
# line 344 "src/7.1/cfe/c.y"
{
			LINK_PUSH_BACK(yyval.node, yypvt[-0].node);
		} break;
case 21:
# line 351 "src/7.1/cfe/c.y"
{ yyval.node = make(Preincrement_expr, yypvt[-1].location, yypvt[-0].node); } break;
case 22:
# line 352 "src/7.1/cfe/c.y"
{ yyval.node = make(Predecrement_expr, yypvt[-1].location, yypvt[-0].node); } break;
case 23:
# line 353 "src/7.1/cfe/c.y"
{ UNARY_EXPR(yyval.node).operand[0] = yypvt[-0].node; } break;
case 24:
# line 355 "src/7.1/cfe/c.y"
{
			TreeNode* spFC = make(Identifier, yypvt[-0].location, builtins[6]);
			yyval.node = make(Addr_expr, yypvt[-1].location, spFC);
			if (IS_STRICT_ANSI) {
				error(0x2012D, LEVEL_WARNING, yypvt[-0].location);
			}
		} break;
case 25:
# line 362 "src/7.1/cfe/c.y"
{ yyval.node = make(Sizeof_expr, yypvt[-1].location, yypvt[-0].node); } break;
case 26:
# line 363 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 1; } break;
case 27:
# line 363 "src/7.1/cfe/c.y"
{ yyval.node = make(Sizeof_expr, yypvt[-4].location, yypvt[-2].node); } break;
case 28:
# line 364 "src/7.1/cfe/c.y"
{ yyval.node = make(Alignof_expr, yypvt[-1].location, yypvt[-0].node); } break;
case 29:
# line 365 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 1; } break;
case 30:
# line 365 "src/7.1/cfe/c.y"
{ yyval.node = make(Alignof_expr, yypvt[-4].location, yypvt[-2].node); } break;
case 31:
# line 366 "src/7.1/cfe/c.y"
{ yyval.node = make(Classof_expr, yypvt[-1].location, yypvt[-0].node); } break;
case 32:
# line 367 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 1; } break;
case 33:
# line 367 "src/7.1/cfe/c.y"
{ yyval.node = make(Classof_expr, yypvt[-4].location, yypvt[-2].node); } break;
case 34:
# line 371 "src/7.1/cfe/c.y"
{ yyval.node = make(Addr_expr, yypvt[-0].location, NULL); } break;
case 35:
# line 372 "src/7.1/cfe/c.y"
{ yyval.node = make(Indirect_expr, yypvt[-0].location, NULL); } break;
case 36:
# line 373 "src/7.1/cfe/c.y"
{ yyval.node = make(Uplus_expr, yypvt[-0].location, NULL); } break;
case 37:
# line 374 "src/7.1/cfe/c.y"
{ yyval.node = make(Uminus_expr, yypvt[-0].location, NULL); } break;
case 38:
# line 375 "src/7.1/cfe/c.y"
{ yyval.node = make(Bitcomplement_expr, yypvt[-0].location, NULL); } break;
case 39:
# line 376 "src/7.1/cfe/c.y"
{ yyval.node = make(Not_expr, yypvt[-0].location, NULL); } break;
case 41:
# line 381 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 1; } break;
case 42:
# line 381 "src/7.1/cfe/c.y"
{ yyval.node = make(Cast_expr, yypvt[-4].location, yypvt[-3].node, yypvt[-0].node); } break;
case 43:
# line 382 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 1; } break;
case 44:
# line 383 "src/7.1/cfe/c.y"
{
			TreeNode* spF8 = make(Cast_expr, yypvt[-4].location, yypvt[-3].node, yypvt[-0].node);
			yyval.node = func_00409D18(Predecrement_expr, yypvt[-5].location, spF8);
		} break;
case 45:
# line 387 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 1; } break;
case 46:
# line 388 "src/7.1/cfe/c.y"
{
			TreeNode* spF4 = make(Cast_expr, yypvt[-4].location, yypvt[-3].node, yypvt[-0].node);
			yyval.node = func_00409D18(Preincrement_expr, yypvt[-5].location, spF4);
		} break;
case 48:
# line 396 "src/7.1/cfe/c.y"
{ yyval.node = make(Mult_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 49:
# line 397 "src/7.1/cfe/c.y"
{ yyval.node = make(Div_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 50:
# line 398 "src/7.1/cfe/c.y"
{ yyval.node = make(Rem_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 52:
# line 403 "src/7.1/cfe/c.y"
{ yyval.node = make(Plus_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 53:
# line 404 "src/7.1/cfe/c.y"
{ yyval.node = make(Minus_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 55:
# line 409 "src/7.1/cfe/c.y"
{ yyval.node = make(Lshift_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 56:
# line 410 "src/7.1/cfe/c.y"
{ yyval.node = make(Rshift_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 58:
# line 415 "src/7.1/cfe/c.y"
{ yyval.node = make(Leq_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 59:
# line 416 "src/7.1/cfe/c.y"
{ yyval.node = make(Geq_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 60:
# line 417 "src/7.1/cfe/c.y"
{ yyval.node = make(Lt_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 61:
# line 418 "src/7.1/cfe/c.y"
{ yyval.node = make(Gt_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 63:
# line 423 "src/7.1/cfe/c.y"
{ yyval.node = make(Eq_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 64:
# line 424 "src/7.1/cfe/c.y"
{ yyval.node = make(Neq_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 66:
# line 429 "src/7.1/cfe/c.y"
{ yyval.node = make(Bitand_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 68:
# line 434 "src/7.1/cfe/c.y"
{ yyval.node = make(Bitxor_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 70:
# line 439 "src/7.1/cfe/c.y"
{ yyval.node = make(Bitor_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 72:
# line 444 "src/7.1/cfe/c.y"
{ yyval.node = make(And_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 74:
# line 449 "src/7.1/cfe/c.y"
{ yyval.node = make(Or_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 76:
# line 454 "src/7.1/cfe/c.y"
{ yyval.node = make(Conditional_expr, yypvt[-3].location, yypvt[-4].node, yypvt[-2].node, yypvt[-0].node); } break;
case 78:
# line 460 "src/7.1/cfe/c.y"
{
			BINARY_EXPR(yypvt[-1].node).operand[0] = yypvt[-2].node;
			BINARY_EXPR(yypvt[-1].node).operand[1] = yypvt[-0].node;
			yyval.node = yypvt[-1].node;
		} break;
case 79:
# line 468 "src/7.1/cfe/c.y"
{ yyval.node = make(Assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 80:
# line 469 "src/7.1/cfe/c.y"
{ yyval.node = make(Mult_assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 81:
# line 470 "src/7.1/cfe/c.y"
{ yyval.node = make(Div_assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 82:
# line 471 "src/7.1/cfe/c.y"
{ yyval.node = make(Rem_assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 83:
# line 472 "src/7.1/cfe/c.y"
{ yyval.node = make(Plus_assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 84:
# line 473 "src/7.1/cfe/c.y"
{ yyval.node = make(Minus_assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 85:
# line 474 "src/7.1/cfe/c.y"
{ yyval.node = make(Lshift_assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 86:
# line 475 "src/7.1/cfe/c.y"
{ yyval.node = make(Rshift_assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 87:
# line 476 "src/7.1/cfe/c.y"
{ yyval.node = make(Bitand_assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 88:
# line 477 "src/7.1/cfe/c.y"
{ yyval.node = make(Bitxor_assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 89:
# line 478 "src/7.1/cfe/c.y"
{ yyval.node = make(Bitor_assign_expr, yypvt[-0].location, NULL, NULL); } break;
case 91:
# line 483 "src/7.1/cfe/c.y"
{ yyval.node = make(Comma_expr, yypvt[-1].location, yypvt[-2].node, yypvt[-0].node); } break;
case 93:
# line 492 "src/7.1/cfe/c.y"
{
			if (B_10020F04 == 0) {
                error(0x2007B, LEVEL_ERROR, curloc);
            }
			yyval.node = make_topdecl(yypvt[-2].declspec.unk_00, yypvt[-2].declspec.unk_04, yypvt[-2].declspec.unk_08, yypvt[-1].list.first, yypvt[-2].declspec.unk_0C);
			cur_lvl->unk_04 = 1;
			cur_lvl->unk_08 = 1;
		} break;
case 94:
# line 501 "src/7.1/cfe/c.y"
{
			if (B_10020F04 == 0) {
                error(0x2007B, LEVEL_ERROR, curloc);
            }
			yyval.node = make_topdecl(yypvt[-1].declspec.unk_00, yypvt[-1].declspec.unk_04, yypvt[-1].declspec.unk_08, NULL, yypvt[-1].declspec.unk_0C);
			cur_lvl->unk_04 = 1;
			cur_lvl->unk_08 = 1;
		} break;
case 95:
# line 513 "src/7.1/cfe/c.y"
{
			yyval.node = make_topdecl(yypvt[-2].declspec.unk_00, yypvt[-2].declspec.unk_04, yypvt[-2].declspec.unk_08, yypvt[-1].list.first, yypvt[-2].declspec.unk_0C);
			cur_lvl->unk_04 = 1;
			cur_lvl->unk_08 = 1;
		} break;
case 96:
# line 519 "src/7.1/cfe/c.y"
{
			yyval.node = make_topdecl(yypvt[-1].declspec.unk_00, yypvt[-1].declspec.unk_04, yypvt[-1].declspec.unk_08, NULL, yypvt[-1].declspec.unk_0C);
			cur_lvl->unk_04 = 1;
			cur_lvl->unk_08 = 1;
		} break;
case 97:
# line 525 "src/7.1/cfe/c.y"
{
			yyval.node = make_topdecl(NULL, 0, 0, yypvt[-1].list.first, TREE_LOCATION(yypvt[-1].list.first));
			error(0x20092, LEVEL_DEFAULT, TREE_LOCATION(yypvt[-1].list.first));
		} break;
case 101:
# line 536 "src/7.1/cfe/c.y"
{
			if ((yyval.declspec.unk_04 & 0x1F000000) && (yypvt[-0].declspec.unk_04 & 0x1F000000)) {
				error(0x20103, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, attribute_to_string(yypvt[-0].declspec.unk_04));
			} else if (yyval.declspec.unk_04 & yypvt[-0].declspec.unk_04) {
				error(0x20094, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, attribute_to_string(yypvt[-0].declspec.unk_04));
			} else {
				yyval.declspec.unk_04 |= yypvt[-0].declspec.unk_04;
				yyval.declspec.unk_0C = yypvt[-0].declspec.unk_0C;
			}
		} break;
case 102:
# line 547 "src/7.1/cfe/c.y"
{
			if (yyval.declspec.unk_00 != NULL) {
				error(0x20162, LEVEL_WARNING, TREE_LOCATION(yyval.declspec.unk_00));
			}
			if (yypvt[-0].declspec.unk_00 != NULL) {
				yyval.declspec.unk_00 = yypvt[-0].declspec.unk_00;
			} else if (yyval.declspec.unk_08 & yypvt[-0].declspec.unk_08) {
				if (yypvt[-0].declspec.unk_08 == 0x01000000) {
					if (IS_STRICT_ANSI) {
						error(0x20131, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, "long long");
					}
					yyval.declspec.unk_08 = yyval.declspec.unk_08 ^ yypvt[-0].declspec.unk_08;
					yyval.declspec.unk_08 |= 0x800000;
				} else {
					error(0x20094, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, type_to_string(yypvt[-0].declspec.unk_08));
				}
			} else {
				yyval.declspec.unk_08 |= yypvt[-0].declspec.unk_08;
			}
		} break;
case 103:
# line 568 "src/7.1/cfe/c.y"
{
			if ((yyval.declspec.unk_04 & 0x1F000000) && (yypvt[-0].declspec.unk_04 & 0x1F000000)) {
				error(0x20103, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, attribute_to_string(yypvt[-0].declspec.unk_04));
			} else if (yyval.declspec.unk_04 & yypvt[-0].declspec.unk_04) {
				error(0x20094, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, attribute_to_string(yypvt[-0].declspec.unk_04));
			} else {
				yyval.declspec.unk_04 |= yypvt[-0].declspec.unk_04;
				yyval.declspec.unk_0C = yypvt[-0].declspec.unk_0C;
			}
		} break;
case 105:
# line 580 "src/7.1/cfe/c.y"
{
			if ((yyval.declspec.unk_04 & 0x1F000000) && (yypvt[-0].declspec.unk_04 & 0x1F000000)) {
				error(0x20103, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, attribute_to_string(yypvt[-0].declspec.unk_04));
			} else if (yyval.declspec.unk_04 & yypvt[-0].declspec.unk_04) {
				error(0x20094, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, attribute_to_string(yypvt[-0].declspec.unk_04));
			} else {
				yyval.declspec.unk_04 |= yypvt[-0].declspec.unk_04;
				yyval.declspec.unk_0C = yypvt[-0].declspec.unk_0C;
			}
		} break;
case 106:
# line 594 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0x80000;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = yypvt[-0].location;
		} break;
case 107:
# line 603 "src/7.1/cfe/c.y"
{
			yyval.list.first = yyval.list.last = yypvt[-0].node;
		} break;
case 108:
# line 606 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 0; } break;
case 109:
# line 607 "src/7.1/cfe/c.y"
{
			if (yyval.list.first == NULL) {
				yyval.list.first = yyval.list.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				yyval.list.last = TREE_LINK(yyval.list.last) = yypvt[-0].node;
			}
		} break;
case 110:
# line 618 "src/7.1/cfe/c.y"
{
			if (yypvt[-0].declarator.unk_00) {
				delete_local_decls(B_10020F04);
                cur_lvl = link_pop(B_10020F00);
                B_10020F04--;
			}
			yyval.node = yypvt[-0].declarator.unk_04;
		} break;
case 111:
# line 627 "src/7.1/cfe/c.y"
{
			if (yypvt[-2].declarator.unk_00) {
				delete_local_decls(B_10020F04);
                cur_lvl = link_pop(B_10020F00);
                B_10020F04--;
			}
			ID_DECL(yypvt[-2].declarator.unk_04).init_value = yypvt[-0].node;
			yyval.node = yypvt[-2].declarator.unk_04;
		} break;
case 112:
# line 640 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0x10000000;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_08 = 0;
		} break;
case 113:
# line 648 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0x08000000;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = yypvt[-0].location;
		} break;
case 114:
# line 655 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0x04000000;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = yypvt[-0].location;
		} break;
case 115:
# line 662 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0x02000000;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = yypvt[-0].location;
		} break;
case 116:
# line 669 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0x01000000;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = yypvt[-0].location;
		} break;
case 117:
# line 679 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0x04000000;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_04 = 0;
		} break;
case 118:
# line 687 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0x400000;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_04 = 0;
		} break;
case 119:
# line 695 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0x02000000;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_04 = 0;
		} break;
case 120:
# line 703 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0x01000000;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_04 = 0;
		} break;
case 121:
# line 711 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0x800000;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_04 = 0;
		} break;
case 122:
# line 719 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0x200000;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_04 = 0;
		} break;
case 123:
# line 727 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0x100000;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_04 = 0;
		} break;
case 124:
# line 735 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0x10000000;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_04 = 0;
		} break;
case 125:
# line 743 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0x40000000;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_04 = 0;
		} break;
case 126:
# line 751 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0x4000;
			yyval.declspec.unk_0C = yypvt[-0].location;
			cur_lvl->unk_04 = 0;
		} break;
case 127:
# line 759 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = yypvt[-0].node;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = TREE_LOCATION(yypvt[-0].node);
			cur_lvl->unk_04 = 0;
		} break;
case 128:
# line 767 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = yypvt[-0].node;
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = TREE_LOCATION(yypvt[-0].node);
			cur_lvl->unk_04 = 0;
		} break;
case 129:
# line 775 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = make(Identifier, yypvt[-0].identifier.location, yypvt[-0].identifier.symbol);
			yyval.declspec.unk_04 = 0;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = yypvt[-0].identifier.location;
		} break;
case 130:
# line 785 "src/7.1/cfe/c.y"
{
			if (debug_arr['y'] > 0) {
				fprintf(dbgout, "IDENT=%s, was_typedef=%d\n", yypvt[-1].identifier.symbol->name, yypvt[-1].identifier.was_typedef);
			}
			cur_lvl = (UnkChi*)get_link_elem(B_10020F00);
			cur_lvl->unk_04 = 1;
			cur_lvl->in_struct_def = TRUE;
			cur_lvl->link.next = B_10020F00->used_list;
    		B_10020F00->used_list = &cur_lvl->link;
		} break;
case 131:
# line 796 "src/7.1/cfe/c.y"
{
			STRUCT_TYPE(yyval.node).sname = make(Id_decl, yypvt[-4].identifier.location, yypvt[-4].identifier.symbol);
			STRUCT_TYPE(yyval.node).members = yypvt[-1].node;
			cur_lvl = link_pop(B_10020F00);
            if (B_10020F04 == 0) {
                tree_handle = cur_lvl->unk_14;
            }
		} break;
case 132:
# line 805 "src/7.1/cfe/c.y"
{
			cur_lvl = (UnkChi*)get_link_elem(B_10020F00);
			cur_lvl->unk_04 = 1;
			cur_lvl->in_struct_def = TRUE;
			cur_lvl->link.next = B_10020F00->used_list;
    		B_10020F00->used_list = &cur_lvl->link;
		} break;
case 133:
# line 813 "src/7.1/cfe/c.y"
{
			STRUCT_TYPE(yyval.node).members = yypvt[-1].node;
			cur_lvl = link_pop(B_10020F00);
            if (B_10020F04 == 0) {
                tree_handle = cur_lvl->unk_14;
            }
		} break;
case 134:
# line 821 "src/7.1/cfe/c.y"
{
			if (debug_arr['y'] > 0) {
				fprintf(dbgout, "IDENT=%s, was_typedef=%d\n", yypvt[-0].identifier.symbol->name, yypvt[-0].identifier.was_typedef);
			}
			STRUCT_TYPE(yyval.node).sname = make(Id_decl, yypvt[-0].identifier.location, yypvt[-0].identifier.symbol);
			cur_lvl->unk_04 = 1;
			if (B_10020F04 == 0) {
                tree_handle = cur_lvl->unk_14;
            }
		} break;
case 135:
# line 835 "src/7.1/cfe/c.y"
{
			if (B_10020F04 == 0) {
                cur_lvl->unk_14 = tree_handle;
                tree_handle = general_handle;
            }
            yyval.node = make(Struct_type, yypvt[-0].location, STRUCT_INFO_STRUCT);
            cur_lvl->unk_04 = 0;
		} break;
case 136:
# line 844 "src/7.1/cfe/c.y"
{
			if (B_10020F04 == 0) {
                cur_lvl->unk_14 = tree_handle;
                tree_handle = general_handle;
            }
            yyval.node = make(Struct_type, yypvt[-0].location, STRUCT_INFO_UNION);
            cur_lvl->unk_04 = 0;
		} break;
case 137:
# line 855 "src/7.1/cfe/c.y"
{ error(0x20097, LEVEL_DEFAULT, curloc); } break;
case 140:
# line 862 "src/7.1/cfe/c.y"
{
			LINK_PUSH_BACK(yyval.node, yypvt[-0].node);
		} break;
case 141:
# line 868 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 0; } break;
case 142:
# line 869 "src/7.1/cfe/c.y"
{
			cur_lvl->unk_04 = 1;
			yyval.node = make_topdecl(yypvt[-2].declspec.unk_00, yypvt[-2].declspec.unk_04, yypvt[-2].declspec.unk_08, yypvt[-0].node, yypvt[-2].declspec.unk_0C);
		} break;
case 145:
# line 879 "src/7.1/cfe/c.y"
{
			if (yyval.declspec.unk_00 != NULL) {
				error(0x20162, LEVEL_WARNING, TREE_LOCATION(yyval.declspec.unk_00));
			}
			if (yypvt[-0].declspec.unk_00 != NULL) {
				yyval.declspec.unk_00 = yypvt[-0].declspec.unk_00;
			} else if (yyval.declspec.unk_08 & yypvt[-0].declspec.unk_08) {
				if (yypvt[-0].declspec.unk_08 == 0x01000000) {
					if (IS_STRICT_ANSI) {
						error(0x20131, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, "long long");
					}
					yyval.declspec.unk_08 = yyval.declspec.unk_08 ^ yypvt[-0].declspec.unk_08;
					yyval.declspec.unk_08 |= 0x800000;
				} else {
					error(0x20094, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, type_to_string(yypvt[-0].declspec.unk_08));
				}
			} else {
				yyval.declspec.unk_08 |= yypvt[-0].declspec.unk_08;
			}
		} break;
case 146:
# line 900 "src/7.1/cfe/c.y"
{
			if ((yyval.declspec.unk_04 & 0x1F000000) && (yypvt[-0].declspec.unk_04 & 0x1F000000)) {
				error(0x20103, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, attribute_to_string(yypvt[-0].declspec.unk_04));
			} else if (yyval.declspec.unk_04 & yypvt[-0].declspec.unk_04) {
				error(0x20094, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, attribute_to_string(yypvt[-0].declspec.unk_04));
			} else {
				yyval.declspec.unk_04 |= yypvt[-0].declspec.unk_04;
				yyval.declspec.unk_0C = yypvt[-0].declspec.unk_0C;
			}
		} break;
case 148:
# line 914 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 0; } break;
case 149:
# line 915 "src/7.1/cfe/c.y"
{
			LINK_PUSH_BACK(yyval.node, yypvt[-0].node);
		} break;
case 150:
# line 922 "src/7.1/cfe/c.y"
{
			if (yypvt[-0].declarator.unk_00) {
				delete_local_decls(B_10020F04);
                cur_lvl = link_pop(B_10020F00);
                B_10020F04--;
			}
			yyval.node = make(Field_decl, TREE_LOCATION(yypvt[-0].declarator.unk_04));
			FIELD_DECL(yyval.node).field = yypvt[-0].declarator.unk_04;
		} break;
case 151:
# line 931 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 1; } break;
case 152:
# line 932 "src/7.1/cfe/c.y"
{
			yyval.node = make(Field_decl, TREE_LOCATION(yypvt[-0].node));
			FIELD_DECL(yyval.node).field = make(Id_decl, TREE_LOCATION(yypvt[-0].node), anonymous);
			FIELD_DECL(yyval.node).width = (int)yypvt[-0].node; /* TODO figure out type */
		} break;
case 153:
# line 938 "src/7.1/cfe/c.y"
{
			if (yypvt[-2].declarator.unk_00 != NULL) {
				delete_local_decls(B_10020F04);
                cur_lvl = link_pop(B_10020F00);
                B_10020F04--;
			}
			yyval.node = make(Field_decl, TREE_LOCATION(yypvt[-2].declarator.unk_04));
			FIELD_DECL(yyval.node).field = yypvt[-2].declarator.unk_04;
			FIELD_DECL(yyval.node).width = (int)yypvt[-0].node; /* TODO figure out type */
		} break;
case 154:
# line 949 "src/7.1/cfe/c.y"
{
			error(0x20098, LEVEL_DEFAULT, curloc);
			yyval.node = make(Field_decl, curloc);
		} break;
case 155:
# line 956 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 1; } break;
case 156:
# line 957 "src/7.1/cfe/c.y"
{
			ENUM_TYPE(yyval.node).literals = yypvt[-2].list.first;
			if (yypvt[-1].location != -1) {
				error(0x2007E, LEVEL_DEFAULT, yypvt[-1].location);
			}
			if (B_10020F04 == 0) {
                tree_handle = cur_lvl->unk_14;
            }
		} break;
case 157:
# line 967 "src/7.1/cfe/c.y"
{
			if (debug_arr['y'] > 0) {
				fprintf(dbgout, "IDENT=%s, was_typedef=%d\n", yypvt[-0].identifier.symbol->name, yypvt[-0].identifier.was_typedef);
			}
			cur_lvl->unk_04 = 1;
		} break;
case 158:
# line 974 "src/7.1/cfe/c.y"
{
			ENUM_TYPE(yyval.node).ename = make(Id_decl, yypvt[-5].identifier.location, yypvt[-5].identifier.symbol);
			ENUM_TYPE(yyval.node).literals = yypvt[-2].list.first;
			if (yypvt[-1].location != -1) {
				error(0x2007E, LEVEL_DEFAULT, yypvt[-1].location);
			}
			if (B_10020F04 == 0) {
                tree_handle = cur_lvl->unk_14;
            }
		} break;
case 159:
# line 985 "src/7.1/cfe/c.y"
{
			if (debug_arr['y'] > 0) {
				fprintf(dbgout, "IDENT=%s, was_typedef=%d\n", yypvt[-0].identifier.symbol->name, yypvt[-0].identifier.was_typedef);
			}
			ENUM_TYPE(yyval.node).ename = make(Id_decl, yypvt[-0].identifier.location, yypvt[-0].identifier.symbol);
			cur_lvl->unk_04 = 1;
			if (B_10020F04 == 0) {
                tree_handle = cur_lvl->unk_14;
            }
		} break;
case 160:
# line 998 "src/7.1/cfe/c.y"
{ yyval.location = -1; } break;
case 162:
# line 1004 "src/7.1/cfe/c.y"
{
			if (B_10020F04 == 0) {
                cur_lvl->unk_14 = tree_handle;
                tree_handle = general_handle;
            }
            cur_lvl->unk_04 = 0;
            yyval.node = make(Enum_type, yypvt[-0].location);
		} break;
case 163:
# line 1015 "src/7.1/cfe/c.y"
{ yyval.list.first = yyval.list.last = yypvt[-0].node; } break;
case 164:
# line 1017 "src/7.1/cfe/c.y"
{
			if (yyval.list.first == NULL) {
				yyval.list.first = yyval.list.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				yyval.list.last = TREE_LINK(yyval.list.last) = yypvt[-0].node;
			}
		} break;
case 165:
# line 1028 "src/7.1/cfe/c.y"
{
			if (debug_arr['y'] > 0) {
				fprintf(dbgout, "IDENT=%s, was_typedef=%d\n", yypvt[-0].identifier.symbol->name, yypvt[-0].identifier.was_typedef);
			}
			yyval.node = make(Id_decl, yypvt[-0].identifier.location, yypvt[-0].identifier.symbol);
		} break;
case 166:
# line 1035 "src/7.1/cfe/c.y"
{
			if (debug_arr['y'] > 0) {
				fprintf(dbgout, "IDENT=%s, was_typedef=%d\n", yypvt[-2].identifier.symbol->name, yypvt[-2].identifier.was_typedef);
			}
			yyval.node = make(Id_decl, yypvt[-2].identifier.location, yypvt[-2].identifier.symbol);
			ID_DECL(yyval.node).init_value = yypvt[-0].node;
		} break;
case 167:
# line 1046 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0x40000000;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = yypvt[-0].location;
		} break;
case 168:
# line 1053 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0x80000000;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = yypvt[-0].location;
		} break;
case 169:
# line 1060 "src/7.1/cfe/c.y"
{
			yyval.declspec.unk_00 = NULL;
			yyval.declspec.unk_04 = 0x80;
			yyval.declspec.unk_08 = 0;
			yyval.declspec.unk_0C = yypvt[-0].location;
		} break;
case 171:
# line 1071 "src/7.1/cfe/c.y"
{
			QUALIFIERS_PUSH_BACK(yypvt[-0].declarator.unk_04, yypvt[-1].node);
			yyval.declarator = yypvt[-0].declarator;
		} break;
case 172:
# line 1079 "src/7.1/cfe/c.y"
{
			if (debug_arr['y'] > 0) {
				fprintf(dbgout, "IDENT=%s, was_typedef=%d\n", yypvt[-0].identifier.symbol->name, yypvt[-0].identifier.was_typedef);
			}
			yyval.declarator.unk_00 = 0;
			cur_lvl->unk_04 = 1;
			if (yypvt[-0].identifier.was_typedef && !cur_lvl->in_struct_def && cur_lvl->unk_08 == 1) {
				UnkBeta* spD8;
				mk_parse_symb(yypvt[-0].identifier.symbol, 0, B_10020F04);
				spD8 = (UnkBeta*)get_link_elem(B_10020F08);
				spD8->unk_04 = yypvt[-0].identifier.symbol;
				spD8->link.next = B_10020F08->used_list;
				B_10020F08->used_list = &spD8->link;
			}
			if (!cur_lvl->in_struct_def && cur_lvl->unk_08 == 0 && !yypvt[-0].identifier.was_typedef) {
				UnkBeta* spD4;
				mk_parse_symb(yypvt[-0].identifier.symbol, -1, B_10020F04);
				spD4 = (UnkBeta*)get_link_elem(B_10020F08);
				spD4->unk_04 = yypvt[-0].identifier.symbol;
				spD4->link.next = B_10020F08->used_list;
				B_10020F08->used_list = &spD4->link;
				yyval.declarator.unk_04 = make(Id_decl, yypvt[-0].identifier.location, yypvt[-0].identifier.symbol);
			} else {
				yyval.declarator.unk_04 = make(Id_decl, yypvt[-0].identifier.location, yypvt[-0].identifier.symbol);
			}
		} break;
case 173:
# line 1106 "src/7.1/cfe/c.y"
{
			yyval.declarator = yypvt[-1].declarator;
			cur_lvl->unk_04 = 1;
		} break;
case 174:
# line 1111 "src/7.1/cfe/c.y"
{
			yyval.declarator.unk_04 = make(Array_type, yypvt[-1].location, NULL);
			QUALIFIERS_PUSH_BACK(yypvt[-2].declarator.unk_04, yyval.declarator.unk_04);
			yyval.declarator = yypvt[-2].declarator;
		} break;
case 175:
# line 1117 "src/7.1/cfe/c.y"
{
			yyval.declarator.unk_04 = make(Array_type, yypvt[-2].location, yypvt[-1].node);
			QUALIFIERS_PUSH_BACK(yypvt[-3].declarator.unk_04, yyval.declarator.unk_04);
			yyval.declarator = yypvt[-3].declarator;
		} break;
case 176:
# line 1123 "src/7.1/cfe/c.y"
{
			yyval.declarator.unk_04 = make(Func_type, yypvt[-1].location, NULL);
			QUALIFIERS_PUSH_BACK(yypvt[-2].declarator.unk_04, yyval.declarator.unk_04);
			yyval.declarator = yypvt[-2].declarator;
			if (B_10020F04 >= 2) {
                delete_local_decls(B_10020F04);
                cur_lvl = link_pop(B_10020F00);
                B_10020F04--;
            } else {
                yyval.declarator.unk_00 = 1;
            }
		} break;
case 177:
# line 1136 "src/7.1/cfe/c.y"
{
			yyval.declarator.unk_04 = make(Func_type, yypvt[-2].location, yypvt[-1].list.first);
			QUALIFIERS_PUSH_BACK(yypvt[-3].declarator.unk_04, yyval.declarator.unk_04);
			yyval.declarator = yypvt[-3].declarator;
			if (B_10020F04 >= 2) {
                delete_local_decls(B_10020F04);
                cur_lvl = link_pop(B_10020F00);
                B_10020F04--;
            } else {
                yyval.declarator.unk_00 = 1;
            }
		} break;
case 178:
# line 1149 "src/7.1/cfe/c.y"
{
			yyval.declarator.unk_04 = make(Func_type, yypvt[-2].location, yypvt[-1].list.first);
			QUALIFIERS_PUSH_BACK(yypvt[-3].declarator.unk_04, yyval.declarator.unk_04);
			yyval.declarator = yypvt[-3].declarator;
			if (B_10020F04 >= 2) {
                delete_local_decls(B_10020F04);
                cur_lvl = link_pop(B_10020F00);
                B_10020F04--;
            } else {
                yyval.declarator.unk_00 = 1;
            }
			cur_lvl->unk_04 = 1;
		} break;
case 179:
# line 1166 "src/7.1/cfe/c.y"
{
			cur_lvl = (UnkChi*)get_link_elem(B_10020F00);
			cur_lvl->unk_04 = 1;
			cur_lvl->unk_0C = 0;
			cur_lvl->in_struct_def = FALSE;
			cur_lvl->unk_08 = 1;
			cur_lvl->link.next = B_10020F00->used_list;
			B_10020F00->used_list = &cur_lvl->link;
			B_10020F04++;
		} break;
case 180:
# line 1180 "src/7.1/cfe/c.y"
{
			yyval.node = make(Pointer_type, yypvt[-0].location);
			POINTER_TYPE(yyval.node).size = bit_size[9];
			POINTER_TYPE(yyval.node).align = bit_size[9];
		} break;
case 181:
# line 1186 "src/7.1/cfe/c.y"
{
			yyval.node = make(Pointer_type, yypvt[-0].declspec.unk_0C);
			POINTER_TYPE(yyval.node).size = bit_size[9];
			POINTER_TYPE(yyval.node).align = bit_size[9];
			TREE_ATTRIBUTE(yyval.node) = yypvt[-0].declspec.unk_04;
		} break;
case 182:
# line 1193 "src/7.1/cfe/c.y"
{
			yyval.node = make(Pointer_type, TREE_LOCATION(yypvt[-0].node));
			POINTER_TYPE(yyval.node).size = bit_size[9];
			POINTER_TYPE(yyval.node).align = bit_size[9];
			TYPE_PUSH_BACK(yypvt[-0].node, yyval.node);
			yyval.node = yypvt[-0].node;
		} break;
case 183:
# line 1201 "src/7.1/cfe/c.y"
{
			yyval.node = make(Pointer_type, yypvt[-1].declspec.unk_0C);
			POINTER_TYPE(yyval.node).size = bit_size[9];
			POINTER_TYPE(yyval.node).align = bit_size[9];
			TREE_ATTRIBUTE(yyval.node) = yypvt[-1].declspec.unk_04;
			TYPE_PUSH_BACK(yypvt[-0].node, yyval.node);
			yyval.node = yypvt[-0].node;
		} break;
case 185:
# line 1214 "src/7.1/cfe/c.y"
{
			if ((yyval.declspec.unk_04 & 0x1F000000) && (yypvt[-0].declspec.unk_04 & 0x1F000000)) {
				error(0x20103, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, attribute_to_string(yypvt[-0].declspec.unk_04));
			} else if (yyval.declspec.unk_04 & yypvt[-0].declspec.unk_04) {
				error(0x20094, LEVEL_WARNING, yypvt[-0].declspec.unk_0C, attribute_to_string(yypvt[-0].declspec.unk_04));
			} else {
				yyval.declspec.unk_04 |= yypvt[-0].declspec.unk_04;
				yyval.declspec.unk_0C = yypvt[-0].declspec.unk_0C;
			}
		} break;
case 186:
# line 1228 "src/7.1/cfe/c.y"
{
			cur_lvl->unk_04 = 0;
			yyval.list.first = yyval.list.last = yypvt[-0].node;
		} break;
case 187:
# line 1233 "src/7.1/cfe/c.y"
{
			if (yyval.list.first == NULL) {
				yyval.list.first = yyval.list.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				yyval.list.last = TREE_LINK(yyval.list.last) = yypvt[-0].node;
			}
		} break;
case 188:
# line 1244 "src/7.1/cfe/c.y"
{
			cur_lvl->unk_04 = 0;
			yyval.list.first = yyval.list.last = yypvt[-0].node;
		} break;
case 189:
# line 1249 "src/7.1/cfe/c.y"
{
			cur_lvl->unk_04 = 0;
			yyval.list.first = yyval.list.last = yypvt[-0].node;
		} break;
case 190:
# line 1254 "src/7.1/cfe/c.y"
{
			if (yyval.list.first == NULL) {
				yyval.list.first = yyval.list.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				yyval.list.last = TREE_LINK(yyval.list.last) = yypvt[-0].node;
			}
		} break;
case 191:
# line 1262 "src/7.1/cfe/c.y"
{
			if (yyval.list.first == NULL) {
				yyval.list.first = yyval.list.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				yyval.list.last = TREE_LINK(yyval.list.last) = yypvt[-0].node;	
			}
		} break;
case 193:
# line 1274 "src/7.1/cfe/c.y"
{
			TreeNode* sp98;
			sp98 = make(Id_decl, yypvt[-0].location, builtins[6]);
			sp98 = make(Declare_decl, yypvt[-0].location, ellipsis, sp98);
			yyval.list.first = yyval.list.last = sp98;
			if (IS_STRICT_ANSI) {
				error(0x2012C, LEVEL_WARNING, yypvt[-0].location);
			}
		} break;
case 194:
# line 1284 "src/7.1/cfe/c.y"
{
			TreeNode* sp94;
			sp94 = make(Id_decl, yypvt[-0].location, builtins[6]);
			sp94 = make(Declare_decl, yypvt[-0].location, ellipsis, sp94);
			if (yyval.list.first == NULL) {
				yyval.list.first = yyval.list.last = sp94;
			} else if (sp94 != NULL) {
				yyval.list.last = TREE_LINK(yyval.list.last) = sp94;
			}
		} break;
case 195:
# line 1298 "src/7.1/cfe/c.y"
{
			yyval.list.first = yyval.list.last = yypvt[-0].node;
		} break;
case 196:
# line 1302 "src/7.1/cfe/c.y"
{
			if (yyval.list.first == NULL) {
				yyval.list.first = yyval.list.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				yyval.list.last = TREE_LINK(yyval.list.last) = yypvt[-0].node;
			}
		} break;
case 197:
# line 1313 "src/7.1/cfe/c.y"
{
			if (yypvt[-0].declarator.unk_00 != NULL)	{
				delete_local_decls(B_10020F04);
                cur_lvl = link_pop(B_10020F00);
                B_10020F04--;
			}
			yyval.node = make_topdecl(yypvt[-1].declspec.unk_00, yypvt[-1].declspec.unk_04, yypvt[-1].declspec.unk_08, yypvt[-0].declarator.unk_04, yypvt[-1].declspec.unk_0C);
			cur_lvl->unk_08 = 1;
		} break;
case 198:
# line 1323 "src/7.1/cfe/c.y"
{
			yyval.node = make_topdecl(yypvt[-0].declspec.unk_00, yypvt[-0].declspec.unk_04, yypvt[-0].declspec.unk_08, NULL, yypvt[-0].declspec.unk_0C);
			cur_lvl->unk_04 = 1;
			cur_lvl->unk_08 = 1;
		} break;
case 199:
# line 1329 "src/7.1/cfe/c.y"
{
			yyval.node = make_topdecl(yypvt[-1].declspec.unk_00, yypvt[-1].declspec.unk_04, yypvt[-1].declspec.unk_08, yypvt[-0].node, yypvt[-1].declspec.unk_0C);
			cur_lvl->unk_04 = 1;
			cur_lvl->unk_08 = 1;
		} break;
case 200:
# line 1338 "src/7.1/cfe/c.y"
{
			yyval.node = make_topdecl(yypvt[-0].declspec.unk_00, yypvt[-0].declspec.unk_04, yypvt[-0].declspec.unk_08, NULL, yypvt[-0].declspec.unk_0C);
		} break;
case 201:
# line 1342 "src/7.1/cfe/c.y"
{
			yyval.node = make_topdecl(yypvt[-1].declspec.unk_00, yypvt[-1].declspec.unk_04, yypvt[-1].declspec.unk_08, yypvt[-0].node, yypvt[-1].declspec.unk_0C);
		} break;
case 204:
# line 1351 "src/7.1/cfe/c.y"
{
			TYPE_PUSH_BACK(yypvt[-0].node, yypvt[-1].node);
			yyval.node = yypvt[-0].node;
		} break;
case 205:
# line 1359 "src/7.1/cfe/c.y"
{
			yyval.node = yypvt[-1].node;
		} break;
case 206:
# line 1363 "src/7.1/cfe/c.y"
{
			yyval.node = make(Array_type, yypvt[-1].location, NULL);
		} break;
case 207:
# line 1367 "src/7.1/cfe/c.y"
{
			yyval.node = make(Array_type, yypvt[-2].location, yypvt[-1].node);
		} break;
case 208:
# line 1371 "src/7.1/cfe/c.y"
{
			yyval.node = make(Array_type, yypvt[-1].location, NULL);
			TYPE_PUSH_BACK(yypvt[-2].node, yyval.node);
			yyval.node = yypvt[-2].node;
		} break;
case 209:
# line 1377 "src/7.1/cfe/c.y"
{
			yyval.node = make(Array_type, yypvt[-2].location, yypvt[-1].node);
			TYPE_PUSH_BACK(yypvt[-3].node, yyval.node);
			yyval.node = yypvt[-3].node;
		} break;
case 210:
# line 1383 "src/7.1/cfe/c.y"
{
			yyval.node = make(Func_type, yypvt[-1].location, NULL);
			delete_local_decls(B_10020F04);
            cur_lvl = link_pop(B_10020F00);
            B_10020F04--;
		} break;
case 211:
# line 1390 "src/7.1/cfe/c.y"
{
			yyval.node = make(Func_type, yypvt[-2].location, yypvt[-1].list.first);
			delete_local_decls(B_10020F04);
            cur_lvl = link_pop(B_10020F00);
            B_10020F04--;
		} break;
case 212:
# line 1397 "src/7.1/cfe/c.y"
{
			yyval.node = make(Func_type, yypvt[-1].location, NULL);
			TYPE_PUSH_BACK(yypvt[-2].node, yyval.node);
			yyval.node = yypvt[-2].node;
			delete_local_decls(B_10020F04);
            cur_lvl = link_pop(B_10020F00);
            B_10020F04--;
		} break;
case 213:
# line 1406 "src/7.1/cfe/c.y"
{
			yyval.node = make(Func_type, yypvt[-2].location, yypvt[-1].list.first);
			TYPE_PUSH_BACK(yypvt[-3].node, yyval.node);
			yyval.node = yypvt[-3].node;
			delete_local_decls(B_10020F04);
            cur_lvl = link_pop(B_10020F00);
            B_10020F04--;
		} break;
case 214:
# line 1418 "src/7.1/cfe/c.y"
{
			cur_lvl->unk_04 = 0;
			if (debug_arr['y'] > 0) {
				fprintf(dbgout, "T_IDENT=%s, was_typedef=%d\n", yypvt[-0].identifier.symbol->name, yypvt[-0].identifier.was_typedef);
			}
		} break;
case 216:
# line 1428 "src/7.1/cfe/c.y"
{ tree_handle = temp_handle; } break;
case 217:
# line 1429 "src/7.1/cfe/c.y"
{
			yyval.node = make(Aggregate_expr, TREE_LOCATION(yypvt[-2].list.first), yypvt[-2].list.first);
			if (B_10020F04 == 0) {
				tree_handle = general_handle;
			}
		} break;
case 218:
# line 1438 "src/7.1/cfe/c.y"
{ yyval.list.first = yyval.list.last = yypvt[-0].node; } break;
case 219:
# line 1440 "src/7.1/cfe/c.y"
{
			if (yyval.list.first == NULL) {
				yyval.list.first = yyval.list.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				yyval.list.last = TREE_LINK(yyval.list.last) = yypvt[-0].node;
			}
		} break;
case 227:
# line 1461 "src/7.1/cfe/c.y"
{
			if (debug_arr['y'] > 0) {
				fprintf(dbgout, "IDENT=%s, was_typedef=%d\n", yypvt[-2].identifier.symbol->name, yypvt[-2].identifier.was_typedef);
			}
			yyval.node = make(Id_decl, yypvt[-2].identifier.location, yypvt[-2].identifier.symbol);
			yyval.node = make(Idlabeled_stmt, yypvt[-2].identifier.location, yyval.node, yypvt[-0].node);
		} break;
case 228:
# line 1468 "src/7.1/cfe/c.y"
{ cur_lvl->unk_04 = 1; } break;
case 229:
# line 1469 "src/7.1/cfe/c.y"
{
			yyval.node = make(Id_decl, yypvt[-3].identifier.location, yypvt[-3].identifier.symbol);
			yyval.node = make(Idlabeled_stmt, yypvt[-3].identifier.location, yyval.node, yypvt[-0].node);
		} break;
case 230:
# line 1474 "src/7.1/cfe/c.y"
{
			yyval.node = make(Caselabeled_stmt, yypvt[-3].location, yypvt[-2].node, yypvt[-0].node);
		} break;
case 231:
# line 1478 "src/7.1/cfe/c.y"
{
			yyval.node = make(Defaultlabeled_stmt, yypvt[-2].location, yypvt[-0].node);
		} break;
case 232:
# line 1485 "src/7.1/cfe/c.y"
{
			yyval.node = make(Compound_stmt, yypvt[-1].location, NULL, NULL, yypvt[-0].location);
			delete_local_decls(B_10020F04);
            cur_lvl = link_pop(B_10020F00);
            B_10020F04--;
		} break;
case 233:
# line 1492 "src/7.1/cfe/c.y"
{
			yyval.node = make(Compound_stmt, yypvt[-2].location, NULL, yypvt[-1].list.first, yypvt[-0].location);
			delete_local_decls(B_10020F04);
            cur_lvl = link_pop(B_10020F00);
            B_10020F04--;
		} break;
case 234:
# line 1499 "src/7.1/cfe/c.y"
{
			yyval.node = make(Compound_stmt, yypvt[-2].location, yypvt[-1].list.first, NULL, yypvt[-0].location);
			delete_local_decls(B_10020F04);
            cur_lvl = link_pop(B_10020F00);
            B_10020F04--;
		} break;
case 235:
# line 1506 "src/7.1/cfe/c.y"
{
			yyval.node = make(Compound_stmt, yypvt[-3].location, yypvt[-2].list.first, yypvt[-1].list.first, yypvt[-0].location);
			delete_local_decls(B_10020F04);
            cur_lvl = link_pop(B_10020F00);
            B_10020F04--;
		} break;
case 236:
# line 1516 "src/7.1/cfe/c.y"
{
			if (cur_lvl->unk_0C) {
				cur_lvl = (UnkChi*)get_link_elem(B_10020F00);
				cur_lvl->unk_04 = 1;
				cur_lvl->in_struct_def = FALSE;				
				cur_lvl->unk_08 = 1;
				cur_lvl->link.next = B_10020F00->used_list;
				B_10020F00->used_list = &cur_lvl->link;
				B_10020F04++;
			}
			cur_lvl->unk_08 = 1;
			cur_lvl->unk_0C = 1;
			tree_handle = temp_handle;
		} break;
case 237:
# line 1533 "src/7.1/cfe/c.y"
{ yyval.list.first = yyval.list.last = yypvt[-0].node; } break;
case 238:
# line 1535 "src/7.1/cfe/c.y"
{
			if (yyval.list.first == NULL) {
				yyval.list.first = yyval.list.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				yyval.list.last = TREE_LINK(yyval.list.last) = yypvt[-0].node;
			}
		} break;
case 239:
# line 1545 "src/7.1/cfe/c.y"
{ yyval.list.first = yyval.list.last = yypvt[-0].node; } break;
case 240:
# line 1547 "src/7.1/cfe/c.y"
{
			if (yyval.list.first == NULL) {
				yyval.list.first = yyval.list.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				yyval.list.last = TREE_LINK(yyval.list.last) = yypvt[-0].node;
			}
		} break;
case 241:
# line 1554 "src/7.1/cfe/c.y"
{ yyval.list.first = yyval.list.last = NULL; } break;
case 243:
# line 1560 "src/7.1/cfe/c.y"
{
			yyval.node = make(Expr_stmt, yypvt[-0].location, NULL);
		} break;
case 244:
# line 1564 "src/7.1/cfe/c.y"
{
			yyval.node = make(Expr_stmt, TREE_LOCATION(yypvt[-1].node), yypvt[-1].node);
		} break;
case 245:
# line 1571 "src/7.1/cfe/c.y"
{
			yyval.node = make(If_stmt, yypvt[-4].location, yypvt[-2].node, yypvt[-0].node, NULL);
		} break;
case 246:
# line 1575 "src/7.1/cfe/c.y"
{
			yyval.node = make(If_stmt, yypvt[-6].location, yypvt[-4].node, yypvt[-2].node, yypvt[-0].node);
		} break;
case 247:
# line 1579 "src/7.1/cfe/c.y"
{
			yyval.node = make(Switch_stmt, yypvt[-4].location, yypvt[-2].node, yypvt[-0].node);
		} break;
case 248:
# line 1586 "src/7.1/cfe/c.y"
{
			yyval.node = make(While_stmt, yypvt[-4].location, yypvt[-2].node, yypvt[-0].node);
		} break;
case 249:
# line 1590 "src/7.1/cfe/c.y"
{
			yyval.node = make(Dowhile_stmt, yypvt[-6].location, yypvt[-5].node, yypvt[-2].node);
		} break;
case 250:
# line 1594 "src/7.1/cfe/c.y"
{
			yyval.node = make(For_stmt, yypvt[-5].location, NULL, NULL, NULL, yypvt[-0].node);
		} break;
case 251:
# line 1598 "src/7.1/cfe/c.y"
{
			yyval.node = make(For_stmt, yypvt[-6].location, NULL, NULL, yypvt[-2].node, yypvt[-0].node);
		} break;
case 252:
# line 1602 "src/7.1/cfe/c.y"
{
			yyval.node = make(For_stmt, yypvt[-6].location, NULL, yypvt[-3].node, NULL, yypvt[-0].node);
		} break;
case 253:
# line 1606 "src/7.1/cfe/c.y"
{
			yyval.node = make(For_stmt, yypvt[-7].location, NULL, yypvt[-4].node, yypvt[-2].node, yypvt[-0].node);
		} break;
case 254:
# line 1610 "src/7.1/cfe/c.y"
{
			yyval.node = make(For_stmt, yypvt[-6].location, yypvt[-4].node, NULL, NULL, yypvt[-0].node);
		} break;
case 255:
# line 1614 "src/7.1/cfe/c.y"
{
			yyval.node = make(For_stmt, yypvt[-7].location, yypvt[-5].node, NULL, yypvt[-2].node, yypvt[-0].node);
		} break;
case 256:
# line 1618 "src/7.1/cfe/c.y"
{
			yyval.node = make(For_stmt, yypvt[-7].location, yypvt[-5].node, yypvt[-3].node, NULL, yypvt[-0].node);
		} break;
case 257:
# line 1622 "src/7.1/cfe/c.y"
{
			yyval.node = make(For_stmt, yypvt[-8].location, yypvt[-6].node, yypvt[-4].node, yypvt[-2].node, yypvt[-0].node);
		} break;
case 258:
# line 1629 "src/7.1/cfe/c.y"
{
			if (debug_arr['y'] > 0) {
				fprintf(dbgout, "IDENT=%s, was_typedef=%d\n", yypvt[-1].identifier.symbol->name, yypvt[-1].identifier.was_typedef);
			}
			yyval.node = make(Id_decl, yypvt[-1].identifier.location, yypvt[-1].identifier.symbol);
			yyval.node = make(Goto_stmt, yypvt[-2].location, yyval.node);
		} break;
case 259:
# line 1637 "src/7.1/cfe/c.y"
{
			yyval.node = make(Continue_stmt, yypvt[-1].location);
		} break;
case 260:
# line 1641 "src/7.1/cfe/c.y"
{
			yyval.node = make(Break_stmt, yypvt[-1].location);
		} break;
case 261:
# line 1645 "src/7.1/cfe/c.y"
{
			yyval.node = make(Return_stmt, yypvt[-1].location, NULL);
		} break;
case 262:
# line 1649 "src/7.1/cfe/c.y"
{
			yyval.node = make(Return_stmt, yypvt[-2].location, yypvt[-1].node);
		} break;
case 263:
# line 1653 "src/7.1/cfe/c.y"
{
			yyval.node = make(Leave_stmt, yypvt[-1].location);
		} break;
case 264:
# line 1660 "src/7.1/cfe/c.y"
{
			yyval.node = make(Try_stmt, yypvt[-6].location, yypvt[-2].node, yypvt[-5].node, yypvt[-0].node);
		} break;
case 265:
# line 1664 "src/7.1/cfe/c.y"
{
			yyval.node = make(Try_stmt, yypvt[-3].location, NULL, yypvt[-2].node, yypvt[-0].node);
		} break;
case 266:
# line 1670 "src/7.1/cfe/c.y"
{
			if (B_10020F10.first == NULL) {
				B_10020F10.first = B_10020F10.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				B_10020F10.last = TREE_LINK(B_10020F10.last) = yypvt[-0].node;
			}
			if (temp_handle->current_region - temp_handle->list_start > options[OPTION_T_LEVEL]) {
				YYACCEPT;
			}
			parse_init();
		} break;
case 267:
# line 1682 "src/7.1/cfe/c.y"
{
			if (B_10020F10.first == NULL) {
				B_10020F10.first = B_10020F10.last = yypvt[-0].node;
			} else if (yypvt[-0].node != NULL) {
				B_10020F10.last = TREE_LINK(B_10020F10.last) = yypvt[-0].node;
			}
			if (temp_handle->current_region - temp_handle->list_start > options[OPTION_T_LEVEL]) {
				YYACCEPT;
			}
			parse_init();
		} break;
case 270:
# line 1699 "src/7.1/cfe/c.y"
{
			error(0x2007F, LEVEL_DEFAULT, yypvt[-0].location);
			yyval.node = NULL;
		} break;
case 271:
# line 1704 "src/7.1/cfe/c.y"
{
			tree_handle = general_handle;
			yyval.node = NULL;
		} break;
case 272:
# line 1709 "src/7.1/cfe/c.y"
{
			yyval.node = make(Pragma, yypvt[-6].location, (int)ICONSTANT(yypvt[-4].node).value, yypvt[-2].list);
		} break;
case 273:
# line 1713 "src/7.1/cfe/c.y"
{
			yyval.node = make(Pragma, yypvt[-4].location, (int)ICONSTANT(yypvt[-2].node).value, NULL);
		} break;
case 274:
# line 1720 "src/7.1/cfe/c.y"
{
			if (TREE_CODE(yypvt[-1].declarator.unk_04) == Id_decl) {
				char* sp68 = NULL;
				char* sp64 = NULL;
				int sp60 = 0;
				real_file_line(TREE_LOCATION(yypvt[-1].declarator.unk_04), &sp68, &sp60, 0);
				real_file_line(TREE_LOCATION(yypvt[-0].node), &sp64, &sp60, 0);
				if (sp68 != NULL && sp64 != NULL && strcmp(sp68, sp64) != 0) {
					TREE_LOCATION(yypvt[-1].declarator.unk_04) = TREE_LOCATION(yypvt[-0].node);
				}
			}
			if (ID_DECL(yypvt[-1].declarator.unk_04).qualifiers == NULL || TREE_CODE(ID_DECL(yypvt[-1].declarator.unk_04).qualifiers) != Func_type) {
				error(0x2010A, LEVEL_DEFAULT, TREE_LOCATION(yypvt[-0].node), ID_DECL(yypvt[-1].declarator.unk_04).id->name);
			} else if (TREE_LINK(yypvt[-0].node) != NULL) {
				FUNC_TYPE(ID_DECL(yypvt[-1].declarator.unk_04).qualifiers).decls = TREE_LINK(yypvt[-0].node);
				ID_DECL(yypvt[-1].declarator.unk_04).init_value = yypvt[-0].node;
				TREE_LINK(yypvt[-0].node) = NULL;
			} else {
				ID_DECL(yypvt[-1].declarator.unk_04).init_value = yypvt[-0].node;
			}
			tree_handle = general_handle;
			yyval.node = make_topdecl(int_type, NULL, NULL, yypvt[-1].declarator.unk_04, TREE_LOCATION(yypvt[-1].declarator.unk_04));
		} break;
case 275:
# line 1743 "src/7.1/cfe/c.y"
{ cur_lvl->unk_08 = 1; } break;
case 276:
# line 1744 "src/7.1/cfe/c.y"
{
			if (TREE_CODE(yypvt[-2].declarator.unk_04) == Id_decl) {
				char* sp5C = NULL;
				char* sp58 = NULL;
				int sp54 = 0;
				real_file_line(TREE_LOCATION(yypvt[-2].declarator.unk_04), &sp5C, &sp54, 0);
				real_file_line(TREE_LOCATION(yypvt[-0].node), &sp58, &sp54, 0);
				if (sp5C != NULL && sp58 != NULL && strcmp(sp5C, sp58) != 0) {
					TREE_LOCATION(yypvt[-2].declarator.unk_04) = TREE_LOCATION(yypvt[-0].node);
				}
			}
			if (ID_DECL(yypvt[-2].declarator.unk_04).qualifiers == NULL || TREE_CODE(ID_DECL(yypvt[-2].declarator.unk_04).qualifiers) != Func_type) {
				error(0x2010A, LEVEL_DEFAULT, TREE_LOCATION(yypvt[-0].node), ID_DECL(yypvt[-2].declarator.unk_04).id->name);
			} else if (TREE_LINK(yypvt[-0].node) != NULL) {
				FUNC_TYPE(ID_DECL(yypvt[-2].declarator.unk_04).qualifiers).decls = TREE_LINK(yypvt[-0].node);
				ID_DECL(yypvt[-2].declarator.unk_04).init_value = yypvt[-0].node;
				TREE_LINK(yypvt[-0].node) = NULL;
			} else {
				ID_DECL(yypvt[-2].declarator.unk_04).init_value = yypvt[-0].node;
			}
			tree_handle = general_handle;
			yyval.node = make_topdecl(yypvt[-3].declspec.unk_00, yypvt[-3].declspec.unk_04, yypvt[-3].declspec.unk_08, yypvt[-2].declarator.unk_04, yypvt[-3].declspec.unk_0C);
		} break;
case 278:
# line 1772 "src/7.1/cfe/c.y"
{
			LINK_PUSH_BACK(yypvt[-0].node, yypvt[-1].list.first);
			yyval.node = yypvt[-0].node;
		} break;
case 279:
# line 1778 "src/7.1/cfe/c.y"
{  } break;
case 280:
# line 1779 "src/7.1/cfe/c.y"
{ B_10020F10.first = make(End_of_file, -1); } break;
	}
	goto yystack;		/* reset registers in driver code */
}
